#!/usr/bin/perl -w
use strict;
use File::Basename;
use FindBin qw/$Bin $Script/;
use Getopt::Long;
use Pod::Usage;


my $script_path = $Bin;

my $ref_sv_simA = "$script_path/../Ref_SV/Sim-A.SV.vcf";

my $ref_sv_NA12878 = "$script_path/../Ref_SV/NA12878_DGV-2015_LR-assembly.vcf";	# generated by merging $ref_sv_pacbio and $ref_sv_dgv1, in which DELs with >= 1 Kb, DUPs and INVs in $ref_sv_dgv1 were merged with merge_ref_SV_vcf.pl

my $ref_mei = "$script_path/../Simulated_data/Sim-MEI.chr17.vcf";
my $ref_vei = "$script_path/../Simulated_data/Sim-VEI.chr17.vcf";
my $ref_numt = "$script_path/../Simulated_data/Sim-NUMT.chr17.vcf";



my $min_reads = 0;

my $read_set = 1;

#my @min_reads = (2, 3, 4, 5, 6, 7, 8, 9, 10);
my @min_reads = (2, 3, 4, 5, 6, 7, 8, 9, 10, 12);

my @size = ('A', 'S', 'M', 'L');

my $ref_sv = 'A';

my $ref_sv2 = '';

my $sv_type = 'ALL';

my $target_chr = 'all';

my $exclude_xy = 0;

my $min_sv_len = 30;

my $max_sv_len = 10000000;

my $min_ref_len = 30;

my $max_ref_len = 1200000;

my $var_sd = 125;
#my $ins_sd = 1000;
my $ins_sd = 200;
my $ctx_sd = 1000;
my $mei_sd = 125;

my $min_ctx = 20000;

my $min_overlap_ratio = 0.5;

my $min_qual = 90;
my $min_del_qual = 0;

my $eval_gt = 0;
my $eval_bp = 0;

my $help;

GetOptions(
    'ref|r=s' => \$ref_sv,
    'ref2|r2=s' => \$ref_sv2,
    'sv_type|st=s' => \$sv_type,
    'chr|c=s' => \$target_chr,
    'len|l=i' => \$min_sv_len,
    'xlen|xl=i' => \$max_sv_len,
    'ref_len|rl=i' => \$min_ref_len,
    'ref_xlen|rxl=i' => \$max_ref_len,
    'read_set|rs=i' => \$read_set,
    'sd_ins|sdi=i' => \$ins_sd,
    'ex_xy|xy' => \$exclude_xy,
    'eval_gt|eg' => \$eval_gt,
    'eval_bp|eb' => \$eval_bp,
    'help' => \$help
) or pod2usage(-verbose => 0);
pod2usage(-verbose => 0) if $help;

my $var_file = shift @ARGV;

my $var_base = basename ($var_file);
$var_base = $1 if ($var_base =~ /(.+)\./);

=head1 SYNOPSIS

  evaluate_SV_callers.pl <option> [vcf file]

  Options:
   --ref or -r <STR>        reference SV type (A|N|ME|VE|MT) (A: Sim-A simulated data, N: NA12878 real data, ME: MEI simulated data, VE: VEI simulated data, MT: NUMT simulated data, C: custum data provided by users) [default: A]
   --sv_type or -st <STR>   SV type (ALL|DEL|DUP|INS|INV|TRA) if specifying multi type, e.g., DEL,INS [default: ALL]
   --chr or -c <STR>        target chromosome to be analyzed [all or chr name(s), e.g., 4,5,6,X]
   --len or -l <INT>        minimum size (bp) of SV to be analyzed [default: 30]
   --xlen or -xl <INT>      maximum size of SV to be analyzed [default: 1000000]
   --ref_len or -rl <INT>   minimum size of reference SV [default: 30]
   --ref_xlen or -rxl <INT> maximum size of reference SV [default: 1000000]
   --ovl_rate or -or <FLOAT> minimum reciprocal overlapping rate between reference and called SVs [default: 0.5 for real data, 0.8 (0.6 for SVs < 1 Kb) for Sim-A data]
   --read_set or -rs <INT>  read set of minimum number of reads (1: set1-3,4,5,6,7,8,9; 2: set-23,5,7,9,11,13,15,17,19) [default: 1]
   --sd_ins or -sdi <INT>   maximum allowable length of INS breakpoints [default: 200]
   --ex_xy or xy            exclude chrX and chrY [default: false]
   --eval_gt or -eg         determine genotype accuracy for each SV type with the Sim-A data [default: false]
   --eval_bp or -eb         determine breakpoint and SV size accuracy for each SV type with the Sim-A data [default: false]
   --help or -h             output help message
   
=cut

if ((($eval_gt == 1) or ($eval_bp == 1)) and ($ref_sv ne 'A')){
    die "eval_gt or eval_bp is only effective when ref is \'A\': \n";
}

$min_overlap_ratio = 0.5 if (uc $ref_sv eq 'N');

@min_reads = (2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 30, 40) if ($read_set == 2);

my $ref_sv_tag = $ref_sv;


if (($ref_sv eq 'A') or ($ref_sv eq 'a')){
    $ref_sv = $ref_sv_simA;
    if ($ref_sv2 ne ''){
	$ref_sv = $ref_sv2;
    }
}
elsif (($ref_sv eq 'N') or ($ref_sv eq 'n')){
    $ref_sv = $ref_sv_NA12878;
    if ($ref_sv2 ne ''){
	$ref_sv = $ref_sv2;
    }
}
elsif ($ref_sv =~ /^[Mm][Ee]/){
    $ref_sv = $ref_mei;
}
elsif ($ref_sv =~ /^[Vv][Ee]/){
    $ref_sv = $ref_vei;
}
elsif ($ref_sv =~ /^[Mm][Tt]|^NU/){
    $ref_sv = $ref_numt;
}

$target_chr = 'all' if ($target_chr eq 'ALL');

my %sv_type;

if ($sv_type ne 'ALL'){
    if ($sv_type !~ /,/){
	$sv_type{$sv_type} = 1;
    }
    else{
	my @type = split (/,/, $sv_type);
	map{$sv_type{$_} = 1} @type;
    }
}

print "< Parameter: Min SV length: $min_sv_len, Allowed BP diff: $mei_sd, Ref-SV: MEI >\n" if ($ref_sv eq $ref_mei);
print "< Parameter: Min SV length: $min_sv_len, Allowed BP diff: $mei_sd, Ref-SV: VEI >\n" if ($ref_sv eq $ref_vei);
print "< Parameter: Min SV length: $min_sv_len, Allowed BP diff: $mei_sd, Ref-SV: NUMT >\n" if ($ref_sv eq $ref_numt);

my %ref;
my %refGT;
my %match_ref;
my $ref_del_num = 0;
my $ref_ins_num = 0;
my $ref_inv_num = 0;
my $ref_dup_num = 0;
my $ref_del_s = 0;
my $ref_del_ss = 0;
my $ref_ins_s = 0;
my $ref_dup_s = 0;
my $ref_inv_s = 0;
my $ref_del_m = 0;
my $ref_ins_m = 0;
my $ref_dup_m = 0;
my $ref_inv_m = 0;
my $ref_del_l = 0;
my $ref_ins_l = 0;
my $ref_dup_l = 0;
my $ref_inv_l = 0;

my $ref_alu_num = 0;
my $ref_l1_num = 0;
my $ref_sva_num = 0;
my $ref_hervk_num = 0;

my $ref_vei_num = 0;

my $ref_numt_num = 0;

my %ref_info;
my %dup_pair;

my $gap_bed = "$script_path/../Ref_SV/gap.bed";

my %gap;

open (FILE, $gap_bed) or die "$gap_bed is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    my @line = split (/\s+/, $line);
    my $chr = $line[0];
    my $pos = $line[1];
    my $end = $line[2];
    ${$gap{$chr}}{$pos} = $end;
}
close (FILE);

open (FILE, $ref_sv) or die "$ref_sv is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    next if ($line =~ /^#[^\dXY]+/);
    my @line = split (/\t/, $line);
    my $chr = $line[0];
    $chr =~ s/^#// if ($chr =~ /^#/);
    next if ($target_chr ne 'all') and (($chr ne $target_chr) and ($target_chr !~ /,$chr,|,$chr$|^$chr,/));
    next if (($chr eq 'X') or ($chr eq 'Y')) and ($exclude_xy == 1);
    my $pos = $line[1];
    my $type = $line[2];
#    $type = 'DEL' if ($type eq 'INDEL');
    $type = 'DUP' if ($type eq 'tandem');
    my $type2 = $type;
    $type2 = 'ALU' if ($type eq 'Alu');
    $type = 'MEI' if ($type2 eq 'ALU') or ($type2 eq 'LINE1') or ($type2 eq 'HERVK') or ($type2 eq 'SVA');
    $type2 = 'DUP' if ($type eq 'INS-DUP');
    ${$dup_pair{$chr}}{$pos} = 1 if ($type eq 'INS-DUP');
    my $svlen = 0;
    $svlen = $1 if ($line[7] =~ /SVLEN=-*(\d+)/);
    next if ($svlen < $min_ref_len) and ($type ne 'INS');
    next if ($svlen > $max_ref_len);

    my $end = $pos + $svlen - 1;
    my $gap_overlap = 0;
    foreach my $gstart (sort {$a <=> $b} keys %{$gap{$chr}}){
	my $gend = ${$gap{$chr}}{$gstart};
	if (($pos >= $gstart) and ($pos <= $gend)){
	    if ($type eq 'INS'){
		$gap_overlap = 1;
		last;
	    }
	    else{
		if ($gend - $pos + 1 >= $svlen * 0.5){
		    $gap_overlap = 1;
		    last;
		}
	    }
	}
	elsif (($type ne 'INS') and ($gstart >= $pos) and ($gstart <= $end)){
	    if ($end - $gstart + 1 >= $svlen * 0.5){
		$gap_overlap = 1;
		last;
	    }
	}
	last if ($gstart > $end);
    }
    if ($gap_overlap == 1){
	next;
    }

    my $GT = 'HM';
    $GT = 'HT' if ($line[7] =~ /HT:/);
    if ($type eq 'INS-DUP'){
	${${$ref{'DUP'}}{$chr}}{$pos} = $svlen;
        ${${$refGT{'DUP'}}{$chr}}{$pos} = $GT if ($ref_sv eq $ref_sv_simA);
	next;
    }
    else{
	${${$ref{$type2}}{$chr}}{$pos} = $svlen;
        ${${$refGT{$type2}}{$chr}}{$pos} = $GT if ($ref_sv eq $ref_sv_simA);
	${${$ref_info{$type2}}{$chr}}{$pos} = $line[7];
        ${${$ref{'INS'}}{$chr}}{$pos} = $svlen if ($type =~ /VEI|MEI|NUMT/);
    }
    
    $ref_del_num ++ if ($type eq 'DEL');
    $ref_ins_num ++ if ($type eq 'INS');
    $ref_dup_num ++ if ($type eq 'DUP');
    $ref_inv_num ++ if ($type eq 'INV');
    if ($type eq 'MEI'){
	$ref_alu_num ++ if ($type2 eq 'ALU');
	$ref_l1_num ++ if ($type2 eq 'LINE1');
	$ref_sva_num ++ if ($type2 eq 'SVA');
	$ref_hervk_num ++ if ($type2 eq 'HERVK');
        $ref_ins_num ++;
    }
    elsif ($type eq 'VEI'){
	$ref_vei_num ++;
        $ref_ins_num ++;
    }
    elsif ($type eq 'NUMT'){
	$ref_numt_num ++;
        $ref_ins_num ++;
    }

    if ($svlen <= 1000){
        if (($svlen <= 100) and ($type eq 'DEL')){
            $ref_del_ss ++;
        }
        $ref_del_s ++ if ($type eq 'DEL') and ($svlen > 100);
        $ref_ins_s ++ if ($type eq 'INS');
        $ref_dup_s ++ if ($type eq 'DUP');
        $ref_inv_s ++ if ($type eq 'INV');
    }
    elsif (($svlen > 1000) and ($svlen <= 100000)){
        $ref_del_m ++ if ($type eq 'DEL');
        $ref_ins_m ++ if ($type eq 'INS');
        $ref_dup_m ++ if ($type eq 'DUP');
        $ref_inv_m ++ if ($type eq 'INV');
    }
    elsif ($svlen > 100000){
        $ref_del_l ++ if ($type eq 'DEL');
        $ref_ins_l ++ if ($type eq 'INS');
        $ref_dup_l ++ if ($type eq 'DUP');
        $ref_inv_l ++ if ($type eq 'INV');
    }
}
close (FILE);

my $out_file = "$var_base.eval.txt";
open (OUT, "> $out_file");
if ($ref_sv eq $ref_mei){
    print "Ref-ALU: $ref_alu_num\n";
    print "Ref-L1: $ref_l1_num\n";
    print "Ref-SVA: $ref_sva_num\n";
    print "Ref-HERVK: $ref_hervk_num\n";
    print OUT "Ref-ALU: $ref_alu_num\n";
    print OUT "Ref-L1: $ref_l1_num\n";
    print OUT "Ref-SVA: $ref_sva_num\n";
    print OUT "Ref-HERVK: $ref_hervk_num\n";
}
elsif ($ref_sv eq $ref_vei){
    print "Ref-VEI: $ref_vei_num\n";
    print OUT "Ref-VEI: $ref_vei_num\n";
}
elsif ($ref_sv eq $ref_numt){
    print "Ref-NUMT: $ref_numt_num\n";
    print OUT "Ref-NUMT: $ref_numt_num\n";
}
else{
    print "Ref-DEL: $ref_del_num\ttinny (<= 100 bp): $ref_del_ss\tshort (<= 1.0 kp): $ref_del_s\tmiddle (<= 100 kb): $ref_del_m\tlarge (> 100 kb): $ref_del_l\n";
    print "Ref-INS: $ref_ins_num\tshort (<=1.0 kp): $ref_ins_s\tmiddle (<= 100 kb): $ref_ins_m\tlarge (> 100 kb): $ref_ins_l\n";
    print "Ref-DUP: $ref_dup_num\tshort (<=1.0 kp): $ref_dup_s\tmiddle (<= 100 kb): $ref_dup_m\tlarge (> 100 kb): $ref_dup_l\n";
    print "Ref-INV: $ref_inv_num\tshort (<=1.0 kp): $ref_inv_s\tmiddle (<= 100 kb): $ref_inv_m\tlarge (> 100 kb): $ref_inv_l\n";
    print OUT "Ref-DEL: $ref_del_num\ttinny (<= 100 bp): $ref_del_ss\tshort (<=1.0 kp): $ref_del_s\tmiddle (<= 100 kb): $ref_del_m\tlarge (> 100 kb): $ref_del_l\n";
    print OUT "Ref-INS: $ref_ins_num\tshort (<=1.0 kp): $ref_ins_s\tmiddle (<= 100 kb): $ref_ins_m\tlarge (> 100 kb): $ref_ins_l\n";
    print OUT "Ref-DUP: $ref_dup_num\tshort (<=1.0 kp): $ref_dup_s\tmiddle (<= 100 kb): $ref_dup_m\tlarge (> 100 kb): $ref_dup_l\n";
    print OUT "Ref-INV: $ref_inv_num\tshort (<=1.0 kp): $ref_inv_s\tmiddle (<= 100 kb): $ref_inv_m\tlarge (> 100 kb): $ref_inv_l\n";
}

my %match_del_num;
my %match_ins_num;
my %match_inv_num;
my %match_dup_num;

my %match_del_GT;
my %match_ins_GT;
my %match_inv_GT;
my %match_dup_GT;

my %match_del_GTNA;
my %match_ins_GTNA;
my %match_inv_GTNA;
my %match_dup_GTNA;

my %del_len;
my %dup_len;
my %inv_len;
my %del_bp;
my %dup_bp;
my %inv_bp;
my %ins_bp;

my %call_del_num;
my %call_ins_num;
my %call_inv_num;
my %call_dup_num;

my %nocall_dup_num;
my %nocall_ins_num;
my %recal_del_num;
my %recal_dup_num;

my $call_alu_bp = 0;
my $call_l1_bp = 0;
my $call_sva_bp = 0;
my $call_hervk_bp = 0;
my $call_vei_num = 0;
my $call_numt_num = 0;
my $match_alu_bp = 0;
my $match_l1_bp = 0;
my $match_sva_bp = 0;
my $match_hervk_bp = 0;
my $match_vei_num = 0;
my $match_numt_num = 0;
my $match_numt_int_num = 0;

my %pre_info;
my %overlap;
my %numt_int;
my $dup_flag = 0;
my $ins_flag = 0;
$overlap{'DEL'} = 0;
$overlap{'DUP'} = 0;
$overlap{'INV'} = 0;
$overlap{'INS'} = 0;
$overlap{'TRA'} = 0;
$overlap{'MEI'} = 0;
$overlap{'VEI'} = 0;
$overlap{'NUMT'} = 0;

my %del_FP;
my %FP;
my @TP;
my %TP_ref;
my %FP_ref;
my @match_ref;
my $gt_flag = 0;

open (FILE, $var_file) or die "$var_file is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    if ($line =~ /^#|^$/){
	next;
    }
    my @line = split (/\t/, $line);
    my $chr = $line[0];
    next if ($target_chr ne 'all') and ($chr ne $target_chr);
    my $type = $line[2];
    if ($type eq 'DUP'){
	$dup_flag = 1;
    }
    elsif ($type eq 'INS'){
	$ins_flag = 1;
    }
}
close (FILE);

if ($ref_sv eq $ref_numt){
    my $numt_vcf = "$script_path/../Ref_SV/BB_NUMT.vcf";
    open (FILE, $numt_vcf) or die "$numt_vcf is not found: $!\n";
    while (my $line = <FILE>){
	chomp $line;
	my @line = split (/\t/, $line);
	my $chr = $line[0];
	my $pos = $line[1];
	${$numt_int{$chr}}{$pos} = 1;
    }
    close (FILE);
}

open (FILE, $var_file) or die "$var_file is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    if ($line =~ /^#|^$/){
	next;
    }
    my @line = split (/\t/, $line);
    my $chr = $line[0];
    next if ($target_chr ne 'all') and (($chr ne $target_chr) and ($target_chr !~ /,$chr,|,$chr$|^$chr,/));
    next if ($chr !~ /^\d+$|[XY]/);
    next if (($chr eq 'X') or ($chr eq 'Y')) and ($exclude_xy == 1);
    my $pos = $line[1];
    my $type = '';
    $type = $line[2] if ($line[2] =~ /^DEL$|^DUP$|^INS$|^INV$|^TRA$|^ALU$|^LINE1$|^L1$|^SVA$|^HERVK$|^ERVK$|^VEI$|^NUMT$/i);
    $type = $1 if ($type eq '') and ($line[7] =~ /SVTYPE=(.+?);/);
    $type = uc $type;
    $type = 'TRA' if ($type eq 'CTX');
    my $class = '';
    $class = 'MEI' if ($type =~ /^ALU$|^LINE1$|^L1$|^SVA$|^HERVK$|^ERVK$/i);
    $type = 'INS' if ($type =~ /^ALU$|^LINE1$|^L1$|^SVA$|^HERVK$|^ERVK$|^VEI$|^NUMT$/i);
    next if (!exists $sv_type{$type}) and ($sv_type ne 'ALL');
#    next if ($type ne 'DEL') and ($type ne 'DUP') and ($type ne 'INS') and ($type ne 'INV');
    my $len = 0;
    $len = $1 if ($line[7] =~ /SVLEN=-*(\d+)/);
    next if ($len < $min_sv_len) and ($type ne 'INS');
    next if ($len < 50) and (($type eq 'DUP') or ($type eq 'INV'));
#    next if ($len < $min_sv_len) and ($type ne 'TRA') and ($class ne 'MEI') and ($type ne 'VEI') and ($type ne 'NUMT');
    next if ($len > $max_sv_len);
    if (($type eq 'INS') and ($line[7] =~ /QUAL=(\d+)/)){
	next if ($1 < $min_qual);
    }
    if (($type eq 'DEL') and ($line[7] =~ /QUAL=(\d+)/)){
	next if ($1 < $min_del_qual);
    }
    my $bplen = 0;
    my $end = 0;
    if ($line[7] =~ /END=(\d+);/){
	$end = $1;
    }
    elsif ($bplen > 0){
	$end = $pos + $bplen - 1;
    }
    else{
	$end = $pos + $len - 1;
    }
    my $reads = $1 if ($line[7] =~ /READS=(\d+)/);
    next if ($reads < $min_reads);
    my $GT = 'NA';
    if (@line > 9){
	$GT = 'HM' if ($line[7] =~ /GT=1\/1/) or ($line[9] =~ /^1\/1/);
	$GT = 'HT' if ($line[7] =~ /GT=0\/1/) or ($line[7] =~ /GT=1\/0/) or ($line[9] =~ /^1\/0/) or ($line[9] =~ /^0\/1/);
    }
    else{
	$GT = 'HM' if ($line[7] =~ /GT=1\/1/);
	$GT = 'HT' if ($line[7] =~ /GT=0\/1/) or ($line[7] =~ /GT=1\/0/);
    }
    $gt_flag = 1 if ($GT eq 'HT') or ($GT eq 'HM');
    my $gap_overlap = 0;
    foreach my $gstart (sort {$a <=> $b} keys %{$gap{$chr}}){
	my $gend = ${$gap{$chr}}{$gstart};
	if (($pos >= $gstart) and ($pos <= $gend)){
	    if ($type eq 'INS'){
		$gap_overlap = 1;
		last;
	    }
	    else{
		if ($gend - $pos + 1 >= $len * 0.3){
#		if (($gend - $pos + 1 >= $len * 0.3) or ($gend - $pos + 1 >= $gend - $gstart * 0.3)){
		    $gap_overlap = 1;
		    last;
		}
	    }
	}
	elsif (($type ne 'INS') and ($gstart >= $pos) and ($gstart <= $end)){
	    if ($end - $gstart + 1 >= $len * 0.3){
#	    if (($end - $gstart + 1 >= $len * 0.3) or ($end - $gstart + 1 >= $gend - $gstart * 0.3)){
		$gap_overlap = 1;
		last;
	    }
	}
	last if ($gstart > $end);
    }
    next if ($gap_overlap == 1);
    my $size = 'S';
    if ($type ne 'INS'){
        if ($len <= 1000){
            $size = 'S';
            if (($len <= 100) and ($type eq 'DEL')){
                $size = 'SS';
            }
        }
        elsif (($len > 1000) and ($len <= 100000)){
            $size = 'M';
        }
        elsif ($len > 100000){
            $size = 'L';
        }
    }
    else{
	if (($line =~ /TOOLS=(\S+)/) and ($ref_sv_tag ne 'N') and ($ref_sv ne $ref_mei) and ($ref_sv ne $ref_vei) and ($ref_sv ne $ref_numt)){
	    if ($1 !~ /Basil|Popins|inGAP|Manta/){
		next;
	    }
	}
    }
    my ($pre_chr, $pre_pos, $pre_size, $pre_hit) = ('', 0, 0, 0);
    ($pre_chr, $pre_pos, $pre_size, $pre_hit) = split (/=/, $pre_info{$type}) if (exists $pre_info{$type});
    if (($type eq 'INS') and ($pre_chr eq $chr) and ($pos - $pre_pos < $var_sd)){
	if ((($len > 0) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)) or ($len == 0)){
	    $overlap{$type} ++;
	    if ($pre_hit == 1){
		$pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
		next;
	    }
	}
    }
    elsif (($type ne 'INS') and ($pre_chr eq $chr) and ($pre_pos + $pre_size - $pos > $len * 0.8) and ($pre_pos + $pre_size - $pos > $pre_size * 0.8) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)){
	$overlap{$type} ++;
	if ($pre_hit == 1){
	    $pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
	    next;
	}
    }
    else{
	if ($type eq 'INS'){
	    foreach my $minread (sort {$a <=> $b} @min_reads){
		if ($reads >= $minread){
		    $call_ins_num{$minread} ++;
		}
	    }
	}
	else{
	    foreach my $minread (sort {$a <=> $b} @min_reads){
		if ($reads >= $minread){
		    ${$call_del_num{$size}}{$minread} ++ if ($type eq 'DEL');
		    ${$call_dup_num{$size}}{$minread} ++ if ($type eq 'DUP') and ($len >= 100);
		    ${$call_inv_num{$size}}{$minread} ++ if ($type eq 'INV') and ($len >= 100);
		    ${$call_del_num{'A'}}{$minread} ++ if ($type eq 'DEL') and ($len >= 50);
		    ${$call_dup_num{'A'}}{$minread} ++ if ($type eq 'DUP') and ($len >= 50);
		    ${$call_inv_num{'A'}}{$minread} ++ if ($type eq 'INV') and ($len >= 50);
		}
	    }
	}
    }
    my $min_overlap_ratio2 = $min_overlap_ratio;
    if ($ref_sv_tag eq 'A'){
	$min_overlap_ratio2 = 0.8  if ($size eq 'M') or ($size eq 'L');
	$min_overlap_ratio2 = 0.6  if ($size eq 'SS') or ($size eq 'S');
    }
    my $flag = 0;
    my $flag2 = 0;
    my $hit_bp = 0;
    my $hit_len = 0;
    if ($type eq 'DEL'){
	my $dellen = 0;
	foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DEL'}}{$chr}}){
	    last if ($bp > $end + $ins_sd);
	    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
	    $dellen = ${${$ref{'DEL'}}{$chr}}{$bp};
	    my $delend = $bp + $dellen - 1;
	    next if ($delend < $pos - $ins_sd);
	    $hit_bp = $bp;
	    $hit_len = $dellen;
	    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $delend) <= $var_sd)){
		$flag = 1;
		${${$match_ref{$type}}{$chr}}{$bp} = 1;
		last;
	    }
	    if (($pos >= $bp) and ($pos <= $delend)){
		if ($end <= $delend){
		    if ($len >= $dellen * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		else{
		    if (($delend - $pos >= $dellen * $min_overlap_ratio2) and ($delend - $pos >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
	    }
	    elsif (($bp >= $pos) and ($bp <= $end)){
		if ($delend <= $end){
		    if ($dellen >= $len * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		else{
		    if (($end - $bp >= $dellen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
	    }
	}
    }
    elsif ($type eq 'DUP'){
	my $duplen = 0;
	foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DUP'}}{$chr}}){
	    last if ($bp > $end + $ins_sd);
	    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
	    $duplen = ${${$ref{'DUP'}}{$chr}}{$bp};
	    my $dupend = $bp + $duplen - 1;
	    next if ($dupend < $pos - $ins_sd);
	    $hit_bp = $bp;
	    $hit_len = $duplen;
	    my $bp2 = $dupend if (!exists ${$dup_pair{$chr}}{$bp});
	    $bp2 = $bp - $duplen + 1 if (exists ${$dup_pair{$chr}}{$bp});
	    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $dupend) <= $var_sd)){
		$flag = 1;
		${${$match_ref{$type}}{$chr}}{$bp} = 1;
#		${${$match_ref{$type}}{$chr}}{$bp2} = 1;
		last;
	    }
	    if (($pos >= $bp) and ($pos <= $dupend)){
		if ($end <= $dupend){
		    if ($len >= $duplen * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
#			${${$match_ref{$type}}{$chr}}{$bp2} = 1;
			last;
		    }
		}
		else{
		    if (($dupend - $pos >= $duplen * $min_overlap_ratio2) and ($dupend - $pos >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
#			${${$match_ref{$type}}{$chr}}{$bp2} = 1;
			last;
		    }
		}
	    }
	    elsif (($bp >= $pos) and ($bp <= $end)){
		if ($dupend <= $end){
		    if ($duplen >= $len * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
#			${${$match_ref{$type}}{$chr}}{$bp2} = 1;
			last;
		    }
		}
		else{
		    if (($end - $bp >= $duplen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
#			${${$match_ref{$type}}{$chr}}{$bp2} = 1;
			last;
		    }
		}
	    }
	}
	if (($flag == 0) and (($ref_sv_tag eq 'N') or ($line =~ /TOOLS/))){
	    foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INS'}}{$chr}}){
		last if ($bp > $end + $len);
		next if (exists ${${$match_ref{'INS'}}{$chr}}{$bp});
		my $inslen = ${${$ref{'INS'}}{$chr}}{$bp};
		next if ($inslen < $min_sv_len);
		my $insend = $bp + $inslen - 1;
		next if ($insend < $pos - $ins_sd);
		if (($pos <= $bp) and ($end >= $insend)){
		    if ($inslen >= $len * $min_overlap_ratio2){
			$flag = 2;
			${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		elsif (($pos >= $bp) and ($end <= $insend)){
		    if ($len >= $inslen * $min_overlap_ratio2){
			$flag = 2;
			${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		elsif (($pos >= $bp) and ($pos <= $insend)){
		    my $overlap = $insend - $pos + 1;
		    if (($overlap >= $len * $min_overlap_ratio2) and ($overlap >= $inslen * $min_overlap_ratio2)){
			$flag = 2;
			${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		elsif (($end >= $bp) and ($end <= $insend)){
		    my $overlap = $end - $bp + 1;
		    if (($overlap >= $len * $min_overlap_ratio2) and ($overlap >= $inslen * $min_overlap_ratio2)){
			$flag = 2;
			${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		if ($flag == 0){
		    if (abs ($end - $bp) <= $ins_sd){
			if (($len >= $inslen) and ($inslen >= $len * $min_overlap_ratio2)){
			    $flag = 2;
			    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			    last;
			}
			elsif (($inslen > $len) and ($len >= $inslen * $min_overlap_ratio2)){
			    $flag = 2;
			    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			    last;
			}
		    }
		}
	    }
	}
    }
    elsif ($type eq 'INS'){
	my $duplen = 0;
	foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INS'}}{$chr}}){
	    last if ($bp > $end + $ins_sd);
	    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
	    next if ($bp < $pos - $ins_sd);
	    $hit_bp = $bp;
	    if (abs ($pos - $bp) <= $ins_sd){
		$flag = 1;
		${${$match_ref{$type}}{$chr}}{$bp} = 1;
	    }
	    last if ($flag > 0);
	}
	if (($flag == 0) and (($dup_flag == 0) or ($line =~ /TOOLS/))){
	    foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DUP'}}{$chr}}){
		last if ($bp > $end + $ins_sd);
		next if (exists ${${$match_ref{'DUP'}}{$chr}}{$bp});
		$duplen = ${${$ref{'DUP'}}{$chr}}{$bp};
		my $dupend = $bp + $duplen - 1;
		next if ($dupend < $pos - $ins_sd);
		$hit_bp = $bp;
		if ((abs ($pos - $bp) <= $ins_sd) or (abs ($pos - $dupend) <= $ins_sd)){
		    $flag = 2;
		    ${${$match_ref{'DUP'}}{$chr}}{$bp} = 1;
		    $ref_ins_num ++;
		    last;
		}
	    }
	}
    }
    elsif ($type eq 'INV'){
	my $invlen = 0;
	foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INV'}}{$chr}}){
	    last if ($bp > $end + $ins_sd);
	    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
	    $invlen = ${${$ref{'INV'}}{$chr}}{$bp};
	    my $invend = $bp + $invlen - 1;
	    next if ($invend < $pos - $ins_sd);
	    $hit_bp = $bp;
	    $hit_len = $invlen;
	    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $invend) <= $var_sd)){
		$flag = 1;
		${${$match_ref{$type}}{$chr}}{$bp} = 1;
		last;
	    }
	    if (($pos >= $bp) and ($pos <= $invend)){
		if ($end <= $invend){
		    if ($len >= $invlen * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		else{
		    if (($invend - $pos >= $invlen * $min_overlap_ratio2) and ($invend - $pos >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
	    }
	    elsif (($bp >= $pos) and ($bp <= $end)){
		if ($invend <= $end){
		    if ($invlen >= $len * $min_overlap_ratio2){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
		else{
		    if (($end - $bp >= $invlen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		}
	    }
	}
    }
    if ($flag == 1){
#push @match_ref, "$pos: $hit_bp=$hit_len" if ($type eq 'DUP') and ($size eq 'L');
	foreach my $minread (sort {$a <=> $b} @min_reads){
	    if ($type eq 'INS'){
		if ($reads >= $minread){
		    $match_ins_num{$minread} ++;
		}
	    }
	    else{
		if ($reads >= $minread){
		    ${$match_del_num{'A'}}{$minread} ++ if ($type eq 'DEL') and ($len >= 50);
		    ${$match_dup_num{'A'}}{$minread} ++ if ($type eq 'DUP') and ($len >= 50);
		    ${$match_inv_num{'A'}}{$minread} ++ if ($type eq 'INV') and ($len >= 50);
		    ${$match_dup_num{$size}}{$minread} ++ if ($type eq 'DUP') and ($len >= 100);
		    ${$match_del_num{$size}}{$minread} ++ if ($type eq 'DEL');
		    ${$match_inv_num{$size}}{$minread} ++ if ($type eq 'INV') and ($len >= 100);
		    if ($size eq 'SS'){
			if ($hit_len > 100){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'S'}}{$minread} ++ if ($type eq 'DEL');
			}
		    }
		    elsif ($size eq 'S'){
			if ($hit_len <= 100){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'SS'}}{$minread} ++ if ($type eq 'DEL');
			}
			elsif ($hit_len > 1000){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'M'}}{$minread} ++ if ($type eq 'DEL');
			    ${$recal_dup_num{$size}}{$minread} -- if ($type eq 'DUP');
			    ${$recal_dup_num{'M'}}{$minread} ++ if ($type eq 'DUP');
			}
		    }
		    elsif ($size eq 'M'){
			if ($hit_len <= 1000){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'S'}}{$minread} ++ if ($type eq 'DEL');
			    ${$recal_dup_num{$size}}{$minread} -- if ($type eq 'DUP');
			    ${$recal_dup_num{'S'}}{$minread} ++ if ($type eq 'DUP');
			}
			elsif ($hit_len > 100000){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'L'}}{$minread} ++ if ($type eq 'DEL');
			    ${$recal_dup_num{$size}}{$minread} -- if ($type eq 'DUP');
			    ${$recal_dup_num{'L'}}{$minread} ++ if ($type eq 'DUP');
			}
		    }
		    elsif ($size eq 'L'){
			if ($hit_len <= 100000){
			    ${$recal_del_num{$size}}{$minread} -- if ($type eq 'DEL');
			    ${$recal_del_num{'M'}}{$minread} ++ if ($type eq 'DEL');
			    ${$recal_dup_num{$size}}{$minread} -- if ($type eq 'DUP');
			    ${$recal_dup_num{'M'}}{$minread} ++ if ($type eq 'DUP');
			}
		    }
		}
	    }
	}
	$pre_info{$type} = "$chr=$pos=$len=1";
    }
    elsif ($flag == 2){
	foreach my $minread (sort {$a <=> $b} @min_reads){
	    if ($type eq 'INS'){
		if ($reads >= $minread){
		    $nocall_ins_num{$minread} ++;
		}
	    }
	    else{
		if ($reads >= $minread){
		    ${$nocall_dup_num{'A'}}{$minread} ++ if ($type eq 'DUP') and ($len >= 50);
		    ${$nocall_dup_num{$size}}{$minread} ++ if ($type eq 'DUP') and ($len >= 100);
		}
	    }
	}
	$pre_info{$type} = "$chr=$pos=$len=1";
    }
    else{
	$pre_info{$type} = "$chr=$pos=$len=0";
    }
    if (($flag >= 1) and ($eval_gt == 1)){
	my $ref_GT = '';
	$ref_GT = ${${$refGT{$type}}{$chr}}{$hit_bp} if (exists ${${$refGT{$type}}{$chr}}{$hit_bp});
	$ref_GT = ${${$refGT{'INS'}}{$chr}}{$hit_bp} if ($ref_GT eq '') and ($type eq 'DUP');
	$ref_GT = ${${$refGT{'DUP'}}{$chr}}{$hit_bp} if ($ref_GT eq '') and ($type eq 'INS');
	foreach my $minread (sort {$a <=> $b} @min_reads){
	    if ($type eq 'INS'){
		if ($reads >= $minread){
		    $match_ins_GT{$minread} ++ if ($GT eq $ref_GT);
		    $match_ins_GTNA{$minread} ++ if ($GT eq 'NA');
		}
	    }
	    else{
		if ($reads >= $minread){
		    ${$match_del_GT{'A'}}{$minread} ++ if ($type eq 'DEL') and ($GT eq $ref_GT);
		    ${$match_dup_GT{'A'}}{$minread} ++ if ($type eq 'DUP') and ($GT eq $ref_GT);
		    ${$match_inv_GT{'A'}}{$minread} ++ if ($type eq 'INV') and ($GT eq $ref_GT);
		    ${$match_del_GTNA{'A'}}{$minread} ++ if ($type eq 'DEL') and ($GT eq 'NA');
		    ${$match_dup_GTNA{'A'}}{$minread} ++ if ($type eq 'DUP') and ($GT eq 'NA');
                    ${$match_inv_GTNA{'A'}}{$minread} ++ if ($type eq 'INV') and ($GT eq 'NA');
                    ${$match_del_GT{$size}}{$minread} ++ if ($type eq 'DEL') and ($GT eq $ref_GT);
                    ${$match_dup_GT{$size}}{$minread} ++ if ($type eq 'DUP') and ($GT eq $ref_GT);
                    ${$match_inv_GT{$size}}{$minread} ++ if ($type eq 'INV') and ($GT eq $ref_GT);
                    ${$match_del_GTNA{$size}}{$minread} ++ if ($type eq 'DEL') and ($GT eq 'NA');
                    ${$match_dup_GTNA{$size}}{$minread} ++ if ($type eq 'DUP') and ($GT eq 'NA');
                    ${$match_inv_GTNA{$size}}{$minread} ++ if ($type eq 'INV') and ($GT eq 'NA');
		}
	    }
	}
    }
    if (($flag >= 1) and ($eval_bp == 1)){
        if ($type eq 'DEL'){
	    $size = 'S' if ($size eq 'SS');
	    push @{$del_bp{$size}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	    push @{$del_bp{'A'}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	    push @{$del_len{$size}}, abs ($len - $hit_len) if ($hit_len > 0);
	    push @{$del_len{'A'}}, abs ($len - $hit_len) if ($hit_len > 0);
	}
	elsif ($type eq 'DUP'){
	    push @{$dup_bp{$size}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	    push @{$dup_bp{'A'}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	    push @{$dup_len{$size}}, abs ($len - $hit_len) if ($hit_len > 0);
	    push @{$dup_len{'A'}}, abs ($len - $hit_len) if ($hit_len > 0);
	}
	elsif ($type eq 'INV'){
	    push @{$inv_bp{'A'}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	    push @{$inv_len{'A'}}, abs ($len - $hit_len) if ($hit_len > 0);
	}
	elsif ($type eq 'INS'){
	    push @{$ins_bp{'A'}}, abs ($pos - $hit_bp) if ($hit_bp > 0);
	}
    }
}
close (FILE);


my $ref_prefix = basename ($ref_sv);
$ref_prefix = $1 if ($ref_prefix =~ /(.+?)\./);
print "<< $ref_prefix >>\n\n";
print OUT "\n<< $ref_prefix >>\n\n";

if ((exists $call_del_num{'A'}) and ($ref_del_num > 0)){
    print "## DEL ##\n";
    print "        \tRSS (Number of supporting reads)\n";
    print "        ";
    print OUT "## DEL ##\n";
    print OUT "        \tRSS (Number of supporting reads)\n";
    print OUT "        ";
    foreach my $minread (sort {$a <=> $b} @min_reads){
	print "\t$minread";
	print OUT "\t$minread";
	if (!exists ${$call_del_num{'A'}}{$minread}){
	    ${$call_del_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$call_del_num{'SS'}}{$minread}){
	    ${$call_del_num{'SS'}}{$minread} = 0;
	}
	if (!exists ${$call_del_num{'S'}}{$minread}){
	    ${$call_del_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$call_del_num{'M'}}{$minread}){
	    ${$call_del_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$call_del_num{'L'}}{$minread}){
	    ${$call_del_num{'L'}}{$minread} = 0;
	}
	if (!exists ${$match_del_num{'A'}}{$minread}){
	    ${$match_del_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$match_del_num{'SS'}}{$minread}){
	    ${$match_del_num{'SS'}}{$minread} = 0;
	}
	if (!exists ${$match_del_num{'S'}}{$minread}){
	    ${$match_del_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$match_del_num{'M'}}{$minread}){
	    ${$match_del_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$match_del_num{'L'}}{$minread}){
	    ${$match_del_num{'L'}}{$minread} = 0;
	}
        if ($eval_gt == 1){
            if (!exists ${$match_del_GT{'A'}}{$minread}){
                ${$match_del_GT{'A'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GT{'SS'}}{$minread}){
                ${$match_del_GT{'SS'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GT{'S'}}{$minread}){
                ${$match_del_GT{'S'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GT{'M'}}{$minread}){
                ${$match_del_GT{'M'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GT{'L'}}{$minread}){
                ${$match_del_GT{'L'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GTNA{'A'}}{$minread}){
                ${$match_del_GTNA{'A'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GTNA{'SS'}}{$minread}){
                ${$match_del_GTNA{'SS'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GTNA{'S'}}{$minread}){
                ${$match_del_GTNA{'S'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GTNA{'M'}}{$minread}){
                ${$match_del_GTNA{'M'}}{$minread} = 0;
            }
            if (!exists ${$match_del_GTNA{'L'}}{$minread}){
                ${$match_del_GTNA{'L'}}{$minread} = 0;
            }
        }
    }
    print "\nCall (A)\t";
    print OUT "\nCall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_del_num{'A'}}){
	print "${$call_del_num{'A'}}{$read}\t";
	print OUT "${$call_del_num{'A'}}{$read}\t";
    }
    print "\nRecall (A)\t";
    print OUT "\nRecall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'A'}}){
	my $recall = int (${$match_del_num{'A'}}{$read} / $ref_del_num * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (A)\t";
    print OUT "\nPrecis (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'A'}}){
	my $precis = 0;
	$precis = int (${$match_del_num{'A'}}{$read} / ${$call_del_num{'A'}}{$read} * 1000) / 10 if (${$call_del_num{'A'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (A)\t";
	print OUT "\nGenotying (A)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_GT{'A'}}){
	    my $matchGT = ${$match_del_GT{'A'}}{$read};
	    my $match = ${$match_del_num{'A'}}{$read};
	    my $NA = ${$match_del_GTNA{'A'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (SS)\t";
    print OUT "\nCall (SS)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_del_num{'SS'}}){
	print "${$call_del_num{'SS'}}{$read}\t";
	print OUT "${$call_del_num{'SS'}}{$read}\t";
    }
    print "\nRecall (SS)\t";
    print OUT "\nRecall (SS)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'SS'}}){
	my $recall = 0;
	my $norecal = 0;
	$norecal = ${$recal_del_num{'SS'}}{$read} if (exists ${$recal_del_num{'SS'}}{$read});
	$recall = int ((${$match_del_num{'SS'}}{$read} + $norecal) / $ref_del_ss * 1000) / 10 if ($ref_del_ss > 0);
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (SS)\t";
    print OUT "\nPrecis (SS)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'SS'}}){
	my $precis = 0;
	$precis = int (${$match_del_num{'SS'}}{$read} / ${$call_del_num{'SS'}}{$read} * 1000) / 10 if (${$call_del_num{'SS'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (SS)\t";
	print OUT "\nGenotying (SS)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_GT{'A'}}){
	    my $matchGT = ${$match_del_GT{'SS'}}{$read};
	    my $match = ${$match_del_num{'SS'}}{$read};
	    my $NA = ${$match_del_GTNA{'SS'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (S)\t";
    print OUT "\nCall (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_del_num{'S'}}){
	print "${$call_del_num{'S'}}{$read}\t";
	print OUT "${$call_del_num{'S'}}{$read}\t";
    }
    print "\nRecall (S)\t";
    print OUT "\nRecall (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'S'}}){
	my $recall = 0;
	my $norecal = 0;
	$norecal = ${$recal_del_num{'S'}}{$read} if (exists ${$recal_del_num{'S'}}{$read});
	$recall = int ((${$match_del_num{'S'}}{$read} + $norecal) / $ref_del_s * 1000) / 10 if ($ref_del_s > 0);
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (S)\t";
    print OUT "\nPrecis (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'S'}}){
	my $precis = 0;
	$precis = int (${$match_del_num{'S'}}{$read} / ${$call_del_num{'S'}}{$read} * 1000) / 10 if (${$call_del_num{'S'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (S)\t";
	print OUT "\nGenotying (S)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_GT{'A'}}){
	    my $matchGT = ${$match_del_GT{'S'}}{$read};
	    my $match = ${$match_del_num{'S'}}{$read};
	    my $NA = ${$match_del_GTNA{'S'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (M)\t";
    print OUT "\nCall (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_del_num{'M'}}){
	print "${$call_del_num{'M'}}{$read}\t";
	print OUT "${$call_del_num{'M'}}{$read}\t";
    }
    print "\nRecall (M)\t";
    print OUT "\nRecall (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'M'}}){
	my $recall = 0;
	my $norecal = 0;
	$norecal = ${$recal_del_num{'M'}}{$read} if (exists ${$recal_del_num{'M'}}{$read});
	$recall = int ((${$match_del_num{'M'}}{$read} + $norecal) / $ref_del_m * 1000) / 10 if ($ref_del_m > 0);
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (M)\t";
    print OUT "\nPrecis (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'M'}}){
	my $precis = 0;
	$precis = int (${$match_del_num{'M'}}{$read} / ${$call_del_num{'M'}}{$read} * 1000) / 10 if (${$call_del_num{'M'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (M)\t";
	print OUT "\nGenotying (M)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_GT{'A'}}){
	    my $matchGT = ${$match_del_GT{'M'}}{$read};
	    my $match = ${$match_del_num{'M'}}{$read};
	    my $NA = ${$match_del_GTNA{'M'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    if ($ref_del_l > 0){
	print "\nCall (L)\t";
	print OUT "\nCall (L)\t";
	foreach my $read (sort {$a <=> $b} keys %{$call_del_num{'L'}}){
	    print "${$call_del_num{'L'}}{$read}\t";
	    print OUT "${$call_del_num{'L'}}{$read}\t";
	}
	print "\nRecall (L)\t";
	print OUT "\nRecall (L)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'L'}}){
	    my $recall = 0;
	    my $norecal = 0;
	    $norecal = ${$recal_del_num{'L'}}{$read} if (exists ${$recal_del_num{'L'}}{$read});
	    $recall = int ((${$match_del_num{'L'}}{$read} + $norecal) / $ref_del_l * 1000) / 10 if ($ref_del_l > 0);
	    print "$recall\t";
	    print OUT "$recall\t";
	}
	print "\nPrecis (L)\t";
	print OUT "\nPrecis (L)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_del_num{'L'}}){
	    my $precis = 0;
	    $precis = int (${$match_del_num{'L'}}{$read} / ${$call_del_num{'L'}}{$read} * 1000) / 10 if (${$call_del_num{'L'}}{$read} > 0);
	    print "$precis\t";
	    print OUT "$precis\t";
	}
        if (($eval_gt == 1) and ($gt_flag == 1)){
            print "\nGenotying (L)\t";
            print OUT "\nGenotying (L)\t";
            foreach my $read (sort {$a <=> $b} keys %{$match_del_GT{'A'}}){
                my $matchGT = ${$match_del_GT{'L'}}{$read};
                my $match = ${$match_del_num{'L'}}{$read};
                my $NA = ${$match_del_GTNA{'L'}}{$read};
                my $precis = 0;
                $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
                print "$precis($match $matchGT $NA)\t";
                print OUT "$precis($match $matchGT $NA)\t";
            }
        }
    }
    if ($eval_bp == 1){
        print "\n";
        print OUT "\n";
        foreach my $size (@size){
            my $SDbp = 0;
            my $SDlen = 0;
            if (exists $del_bp{$size}){
                my $sq_total = 0;
                foreach (@{$del_bp{$size}}){
                    $sq_total += $_ ** 2;
                }
                $SDbp = int (($sq_total / @{$del_bp{$size}}) ** 0.5 + 0.5) if (@{$del_bp{$size}} > 0);
            }
            if (exists $del_len{$size}){
                my $sq_total = 0;
                foreach (@{$del_len{$size}}){
                    $sq_total += $_ ** 2;
                }
                $SDlen = int (($sq_total / @{$del_len{$size}}) ** 0.5 + 0.5) if (@{$del_len{$size}} > 0);
            }
            if (exists $del_bp{$size}){
                print "[Break Points SD ($size)]: $SDbp\t[Size SD ($size)]: $SDlen\n";
                print OUT "[Break Points SD ($size)]: $SDbp\t[Size SD ($size)]: $SDlen\n";
            }
        }
    }
    
    print "\n\n";
    print OUT "\n\n";
}

if ((exists $call_dup_num{'A'}) and ($ref_dup_num > 0)){
    print "## DUP ##\n";
    print "        \tRSS (Number of supporting reads)\n";
    print "        ";
    print OUT "## DUP ##\n";
    print OUT "        \tRSS (Number of supporting reads)\n";
    print OUT "        ";
    foreach my $minread (sort {$a <=> $b} @min_reads){
	print "\t$minread";
	print OUT "\t$minread";
	if (!exists ${$call_dup_num{'A'}}{$minread}){
	    ${$call_dup_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$call_dup_num{'S'}}{$minread}){
	    ${$call_dup_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$call_dup_num{'M'}}{$minread}){
	    ${$call_dup_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$call_dup_num{'L'}}{$minread}){
	    ${$call_dup_num{'L'}}{$minread} = 0;
	}
	if (!exists ${$match_dup_num{'A'}}{$minread}){
	    ${$match_dup_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$match_dup_num{'S'}}{$minread}){
	    ${$match_dup_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$match_dup_num{'M'}}{$minread}){
	    ${$match_dup_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$match_dup_num{'L'}}{$minread}){
	    ${$match_dup_num{'L'}}{$minread} = 0;
	}
        if ($eval_gt == 1){
            if (!exists ${$match_dup_GT{'A'}}{$minread}){
                ${$match_dup_GT{'A'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GT{'S'}}{$minread}){
                ${$match_dup_GT{'S'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GT{'M'}}{$minread}){
                ${$match_dup_GT{'M'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GT{'L'}}{$minread}){
                ${$match_dup_GT{'L'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GTNA{'A'}}{$minread}){
                ${$match_dup_GTNA{'A'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GTNA{'S'}}{$minread}){
                ${$match_dup_GTNA{'S'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GTNA{'M'}}{$minread}){
                ${$match_dup_GTNA{'M'}}{$minread} = 0;
            }
            if (!exists ${$match_dup_GTNA{'L'}}{$minread}){
                ${$match_dup_GTNA{'L'}}{$minread} = 0;
            }
        }
    }
    print "\nCall (A)\t";
    print OUT "\nCall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_dup_num{'A'}}){
	print "${$call_dup_num{'A'}}{$read}\t";
	print OUT "${$call_dup_num{'A'}}{$read}\t";
    }
    print "\nRecall (A)\t";
    print OUT "\nRecall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'A'}}){
	my $recall = int (${$match_dup_num{'A'}}{$read} / $ref_dup_num * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (A)\t";
    print OUT "\nPrecis (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'A'}}){
	my $precis = 0;
	my $call = ${$call_dup_num{'A'}}{$read};
	$call -= ${$nocall_dup_num{'A'}}{$read} if (exists ${$nocall_dup_num{'A'}}{$read});
	$precis = int (${$match_dup_num{'A'}}{$read} / $call * 1000) / 10 if ($call > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (A)\t";
	print OUT "\nGenotying (A)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_dup_GT{'A'}}){
	    my $matchGT = ${$match_dup_GT{'A'}}{$read};
	    my $match = ${$match_dup_num{'A'}}{$read};
	    my $NA = ${$match_dup_GTNA{'A'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (S)\t";
    print OUT "\nCall (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_dup_num{'S'}}){
	print "${$call_dup_num{'S'}}{$read}\t";
	print OUT "${$call_dup_num{'S'}}{$read}\t";
    }
    print "\nRecall (S)\t";
    print OUT "\nRecall (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'S'}}){
	my $norecal = 0;
	$norecal = ${$recal_dup_num{'S'}}{$read} if (exists ${$recal_dup_num{'S'}}{$read});
	my $recall = int ((${$match_dup_num{'S'}}{$read} + $norecal) / $ref_dup_s * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (S)\t";
    print OUT "\nPrecis (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'S'}}){
	my $precis = 0;
	my $call = ${$call_dup_num{'S'}}{$read};
	$call -= ${$nocall_dup_num{'S'}}{$read} if (exists ${$nocall_dup_num{'S'}}{$read});
	$precis = int (${$match_dup_num{'S'}}{$read} / $call * 1000) / 10 if ($call > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (S)\t";
	print OUT "\nGenotying (S)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_dup_GT{'S'}}){
	    my $matchGT = ${$match_dup_GT{'S'}}{$read};
	    my $match = ${$match_dup_num{'S'}}{$read};
	    my $NA = ${$match_dup_GTNA{'S'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (M)\t";
    print OUT "\nCall (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_dup_num{'M'}}){
	print "${$call_dup_num{'M'}}{$read}\t";
	print OUT "${$call_dup_num{'M'}}{$read}\t";
    }
    print "\nRecall (M)\t";
    print OUT "\nRecall (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'M'}}){
	my $norecal = 0;
	$norecal = ${$recal_dup_num{'M'}}{$read} if (exists ${$recal_dup_num{'M'}}{$read});
	my $recall = int ((${$match_dup_num{'M'}}{$read} + $norecal) / $ref_dup_m * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (M)\t";
    print OUT "\nPrecis (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'M'}}){
	my $precis = 0;
	my $call = ${$call_dup_num{'M'}}{$read};
	$call -= ${$nocall_dup_num{'M'}}{$read} if (exists ${$nocall_dup_num{'M'}}{$read});
	$precis = int (${$match_dup_num{'M'}}{$read} / $call * 1000) / 10 if ($call > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (M)\t";
	print OUT "\nGenotying (M)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_dup_GT{'M'}}){
	    my $matchGT = ${$match_dup_GT{'M'}}{$read};
	    my $match = ${$match_dup_num{'M'}}{$read};
	    my $NA = ${$match_dup_GTNA{'M'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    print "\nCall (L)\t";
    print OUT "\nCall (L)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_dup_num{'L'}}){
	print "${$call_dup_num{'L'}}{$read}\t";
	print OUT "${$call_dup_num{'L'}}{$read}\t";
    }
    print "\nRecall (L)\t";
    print OUT "\nRecall (L)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'L'}}){
	my $norecal = 0;
	$norecal = ${$recal_dup_num{'L'}}{$read} if (exists ${$recal_dup_num{'L'}}{$read});
	my $recall = int ((${$match_dup_num{'L'}}{$read} + $norecal) / $ref_dup_l * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (L)\t";
    print OUT "\nPrecis (L)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_dup_num{'L'}}){
	my $precis = 0;
	my $call = ${$call_dup_num{'L'}}{$read};
	$call -= ${$nocall_dup_num{'L'}}{$read} if (exists ${$nocall_dup_num{'L'}}{$read});
	$precis = int (${$match_dup_num{'L'}}{$read} / $call * 1000) / 10 if ($call > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (L)\t";
	print OUT "\nGenotying (L)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_dup_GT{'L'}}){
	    my $matchGT = ${$match_dup_GT{'L'}}{$read};
	    my $match = ${$match_dup_num{'L'}}{$read};
	    my $NA = ${$match_dup_GTNA{'L'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    if ($eval_bp == 1){
        print "\n";
        print OUT "\n";
        foreach my $size (@size){
            my $SDbp = 0;
            my $SDlen = 0;
            if (exists $dup_bp{$size}){
                my $sq_total = 0;
                foreach (@{$dup_bp{$size}}){
                    $sq_total += $_ ** 2;
                }
                $SDbp = int (($sq_total / @{$dup_bp{$size}}) ** 0.5 + 0.5) if (@{$dup_bp{$size}} > 0);
            }
            if (exists $dup_len{$size}){
                my $sq_total = 0;
                foreach (@{$dup_len{$size}}){
                    $sq_total += $_ ** 2;
                }
                $SDlen = int (($sq_total / @{$dup_len{$size}}) ** 0.5 + 0.5) if (@{$dup_len{$size}} > 0);
            }
            if (exists $dup_bp{$size}){
                print "[Break Points SD ($size)]: $SDbp\t[Size SD ($size)]: $SDlen\n";
                print OUT "[Break Points SD ($size)]: $SDbp\t[Size SD ($size)]: $SDlen\n";
            }
        }
    }
    
    print "\n\n";
    print OUT "\n\n";
}

if ((exists $call_ins_num{3}) and ($ref_ins_num > 0)){
    print "## INS ##\n";
    print "        \tRSS (Number of supporting reads)\n";
    print "        ";
    print OUT "## INS ##\n";
    print OUT "        \tRSS (Number of supporting reads)\n";
    print OUT "        ";
    foreach my $minread (sort {$a <=> $b} @min_reads){
	print "\t$minread";
	print OUT "\t$minread";
	if (!exists $call_ins_num{$minread}){
	    $call_ins_num{$minread} = 0;
	}
	if (!exists $match_ins_num{$minread}){
	    $match_ins_num{$minread} = 0;
	}
        if ($eval_gt == 1){
            if (!exists $match_ins_GT{$minread}){
                $match_ins_GT{$minread} = 0;
            }
            if (!exists $match_ins_GTNA{$minread}){
                $match_ins_GTNA{$minread} = 0;
            }
        }
    }
    print "\nCall (A)\t";
    print OUT "\nCall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %call_ins_num){
	print "$call_ins_num{$read}\t";
	print OUT "$call_ins_num{$read}\t";
    }
    print "\nRecall (A)\t";
    print OUT "\nRecall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %match_ins_num){
        my $ref_ins_num2 = $ref_ins_num;
        $ref_ins_num2 -= ${$nocall_dup_num{'A'}}{$read} if (exists ${$nocall_dup_num{'A'}}{$read});
        my $recall = int ($match_ins_num{$read} / $ref_ins_num2 * 1000) / 10;
        print "$recall\t";
        print OUT "$recall\t";
    }
    print "\nPrecis (A)\t";
    print OUT "\nPrecis (A)\t";
    foreach my $read (sort {$a <=> $b} keys %match_ins_num){
	my $precis = 0;
	my $call = $call_ins_num{$read};
	$call -= $nocall_ins_num{$read} if (exists $nocall_ins_num{$read});
	$precis = int ($match_ins_num{$read} / $call * 1000) / 10 if ($call > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (A)\t";
	print OUT "\nGenotying (A)\t";
	foreach my $read (sort {$a <=> $b} keys %match_ins_GT){
	    my $matchGT = $match_ins_GT{$read};
	    my $match = $match_ins_num{$read};
	    my $NA = $match_ins_GTNA{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    if ($eval_bp == 1){
        print "\n";
        print OUT "\n";
        my $SDbp = 0;
        my $SDlen = 0;
        if (exists $ins_bp{'A'}){
            my $sq_total = 0;
            foreach (@{$ins_bp{'A'}}){
                $sq_total += $_ ** 2;
            }
            $SDbp = int (($sq_total / @{$ins_bp{'A'}}) ** 0.5 + 0.5) if (@{$ins_bp{'A'}} > 0);
        }
        if (exists $ins_bp{'A'}){
            print "[Break Points SD ('A')]: $SDbp\n";
            print OUT "[Break Points SD ('A')]: $SDbp\n";
        }
    }
    print "\n\n";
    print OUT "\n\n";
}

if ((exists $call_inv_num{'A'}) and ($ref_inv_num > 0)){
    print "## INV ##\n";
    print "        \tRSS (Number of supporting reads)\n";
    print "        ";
    print OUT "## INV ##\n";
    print OUT "        \tRSS (Number of supporting reads)\n";
    print OUT "        ";
    foreach my $minread (sort {$a <=> $b} @min_reads){
	print "\t$minread";
	print OUT "\t$minread";
	if (!exists ${$call_inv_num{'A'}}{$minread}){
	    ${$call_inv_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$call_inv_num{'S'}}{$minread}){
	    ${$call_inv_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$call_inv_num{'M'}}{$minread}){
	    ${$call_inv_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$call_inv_num{'L'}}{$minread}){
	    ${$call_inv_num{'L'}}{$minread} = 0;
	}
	if (!exists ${$match_inv_num{'A'}}{$minread}){
	    ${$match_inv_num{'A'}}{$minread} = 0;
	}
	if (!exists ${$match_inv_num{'S'}}{$minread}){
	    ${$match_inv_num{'S'}}{$minread} = 0;
	}
	if (!exists ${$match_inv_num{'M'}}{$minread}){
	    ${$match_inv_num{'M'}}{$minread} = 0;
	}
	if (!exists ${$match_inv_num{'L'}}{$minread}){
	    ${$match_inv_num{'L'}}{$minread} = 0;
	}
        if ($eval_gt == 1){
            if (!exists ${$match_inv_GT{'A'}}{$minread}){
                ${$match_inv_GT{'A'}}{$minread} = 0;
            }
            if (!exists ${$match_inv_GTNA{'A'}}{$minread}){
                ${$match_inv_GTNA{'A'}}{$minread} = 0;
            }
        }
    }
    print "\nCall (A)\t";
    print OUT "\nCall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$call_inv_num{'A'}}){
	print "${$call_inv_num{'A'}}{$read}\t";
	print OUT "${$call_inv_num{'A'}}{$read}\t";
    }
    print "\nRecall (A)\t";
    print OUT "\nRecall (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'A'}}){
	my $recall = int (${$match_inv_num{'A'}}{$read} / $ref_inv_num * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (A)\t";
    print OUT "\nPrecis (A)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'A'}}){
	my $precis = 0;
	$precis = int (${$match_inv_num{'A'}}{$read} / ${$call_inv_num{'A'}}{$read} * 1000) / 10 if (${$call_inv_num{'A'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    if (($eval_gt == 1) and ($gt_flag == 1)){
	print "\nGenotying (A)\t";
	print OUT "\nGenotying (A)\t";
	foreach my $read (sort {$a <=> $b} keys %{$match_inv_GT{'A'}}){
	    my $matchGT = ${$match_inv_GT{'A'}}{$read};
	    my $match = ${$match_inv_num{'A'}}{$read};
	    my $NA = ${$match_inv_GTNA{'A'}}{$read};
	    my $precis = 0;
	    $precis = int ($matchGT / ($match - $NA) * 1000) / 10 if ($match - $NA > 0);
	    print "$precis($match $matchGT $NA)\t";
	    print OUT "$precis($match $matchGT $NA)\t";
	}
    }
    if ($eval_bp == 1){
        print "\n";
        print OUT "\n";
        my $SDbp = 0;
        my $SDlen = 0;
        if (exists $inv_bp{'A'}){
            my $sq_total = 0;
            foreach (@{$inv_bp{'A'}}){
                $sq_total += $_ ** 2;
            }
            $SDbp = int (($sq_total / @{$inv_bp{'A'}}) ** 0.5 + 0.5) if (@{$inv_bp{'A'}} > 0);
        }
        if (exists $inv_len{'A'}){
            my $sq_total = 0;
            foreach (@{$inv_len{'A'}}){
                $sq_total += $_ ** 2;
            }
            $SDlen = int (($sq_total / @{$inv_len{'A'}}) ** 0.5 + 0.5) if (@{$inv_len{'A'}} > 0);
        }
        if (exists $inv_bp{'A'}){
            print "[Break Points SD ('A')]: $SDbp\t[Size SD ('A')]: $SDlen\n";
            print OUT "[Break Points SD ('A')]: $SDbp\t[Size SD ('A')]: $SDlen\n";
        }
    }
=pod
    print "\nRecall (S)\t";
    print OUT "\nRecall (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'S'}}){
	my $recall = int (${$match_inv_num{'S'}}{$read} / $ref_inv2_s * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (S)\t";
    print OUT "\nPrecis (S)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'S'}}){
	my $precis = 0;
	$precis = int (${$match_inv_num{'S'}}{$read} / ${$call_inv_num{'S'}}{$read} * 1000) / 10 if (${$call_inv_num{'S'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    print "\nRecall (M)\t";
    print OUT "\nRecall (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'M'}}){
	my $recall = int (${$match_inv_num{'M'}}{$read} / $ref_inv2_m * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (M)\t";
    print OUT "\nPrecis (M)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'M'}}){
	my $precis = 0;
	$precis = int (${$match_inv_num{'M'}}{$read} / ${$call_inv_num{'M'}}{$read} * 1000) / 10 if (${$call_inv_num{'M'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
    print "\nRecall (L)\t";
    print OUT "\nRecall (L)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'L'}}){
	my $recall = int (${$match_inv_num{'L'}}{$read} / $ref_inv2_l * 1000) / 10;
	print "$recall\t";
	print OUT "$recall\t";
    }
    print "\nPrecis (L)\t";
    print OUT "\nPrecis (L)\t";
    foreach my $read (sort {$a <=> $b} keys %{$match_inv_num{'L'}}){
	my $precis = 0;
	$precis = int (${$match_inv_num{'L'}}{$read} / ${$call_inv_num{'L'}}{$read} * 1000) / 10 if (${$call_inv_num{'L'}}{$read} > 0);
	print "$precis\t";
	print OUT "$precis\t";
    }
=cut
    print "\n\n";
    print OUT "\n\n";
#print STDERR "Call: ${$call_inv_num{'L'}}{3}\tMatch: ${$match_inv_num{'L'}}{3}\t$ref_inv2_l\n";
}
close (OUT);

