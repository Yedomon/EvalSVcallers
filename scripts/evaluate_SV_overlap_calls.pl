#!/usr/bin/perl -w
use strict;
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use FindBin qw/$Bin $Script/;

# First, select SVs (shared set) shared between 2 SV sets (A AND B => AB, C AND D => CD), second merge different two shared sets (AB OR CD)

my $eval_file = '';

my $sv_type = 'ALL';

my $sv_size = 'ALL';

my $target_chr = 'all';

my $min_sv_len = 30;

my $max_sv_len = 2000000;

my $max_inv_size = 200000;

my $read_length = 125;
my $var_sd = 125;
my $ins_sd = 200;
my $ctx_sd = 20000;

my $min_ctx = 20000;

my $min_overlap_ratio = 0.6;        # for overlap between SV call sets

my $min_overlap_ratio2 = 0.5;       # for overlap with ref SVs

my $output_vcf = 0;

my $help;

my $ref_sv = 'A';

my $script_path = $Bin;

my $ref_sv_simA = "$script_path/../Ref_SV/Sim-A.SV.vcf";

my $ref_sv_NA12878 = "$script_path/../Ref_SV/NA12878_DGV-2015_LR-assembly.vcf";	# generated by merging $ref_sv_pacbio and $ref_sv_dgv1, in which DELs with >= 1 Kb, DUPs and INVs in $ref_sv_dgv1 were merged with merge_ref_SV_vcf.pl

my $out_prefix = '';

my $input_dir = './';

my @tools;

my $merge_2set = 0;
my $merge_3set = 0;


GetOptions(
    'ref|r=s' => \$ref_sv,
    'tools|t=s{,}' => \@tools,
    'sv_type|st=s' => \$sv_type,
    'sv_size|ss=s' => \$sv_size,
    'var_sd|vsd=i' => \$var_sd,
    'ins_sd|isd=i' => \$ins_sd,
    'ovl_rate1|or1=i' => \$min_overlap_ratio,
    'ovl_rate2|or2=i' => \$min_overlap_ratio2,
    'read_len|rl=i' => \$read_length,
    'dir|d=s' => \$input_dir,
    'prefix|p=s' => \$out_prefix,
    'chr|c=s' => \$target_chr,
    'vcf_out|vcf' => \$output_vcf,
    'help' => \$help
) or pod2usage(-verbose => 0);

=head1 SYNOPSIS

  evaluate_SV_overlap_calls.pl -t <tool:RSS list>
  [Example] evaluate_SV_overlap_calls.pl -t BreakDancer:4 DELLY:3 Manta:3 -p BD-DELLY-Manta-overlap

  Options:
   --ref or -r <STR>        reference SV type [A|N] (A: Sim-A data, N: NA12878 real data) [default: A]
   --tools or -t <STR>      list of tool:RSS, separated with space (e.g., Pindel:3 Lumpy:5) [mandatory]   (RSS: minimum number of reads supporting an SV)
   --sv_type or -st <STR>   SV type (ALL|DEL|DUP|INS|INV|TRA) [default: ALL]
   --sv_size or -ss <STR>   SV size, SS, S, M, L, Lo, or ALL, SS: 30-100 bp, S: 50-1000 bp, M: 1000-100,000 bp, Lo: 500-2,000,000 bp, L: 100,000-2,000,000 bp [default: ALL]
   --min_size or -s <INT>   minimum size (bp) of SV [default: 30]
   --var_sd or -vsd <INT>   standard deviation of break points [default: 125]
   --ins_sd or -isd <INT>   standard deviation of break points for insertions [default: 1000]
   --read_len or -rl <INT>  read length [default: 125]
   --ovl_rate1 or -or1 <FLOAT> minimum overlap rate between SV-1 and SV-2 (except INSs) from 2 call sets [default: 0.6]
   --ovl_rate2 or -or2 <FLOAT> minimum overlap rate between called SV and Ref SV [default: 0.5 for the real data, 0.6 and 0.8 for the size SS/S and M/L of the Sim-A data, respectively]
   --dir or -d <STR>        directory of input vcf files (which should contain vcf files with the tool name sepcified with the -t option, e.g., Pindel.NA78.vcf) [default: ./]
   --prefix or -p <STR>     prefix of output (the result is output in $prefix.eval.txt if specified) [default: STDOUT]
   --vcf_out or -vcf        output vcf file for overlapping calls between tool pairs [default: false]
   --help or -h             output help message
   
=cut

die "tool list (--tools) not specified: \n" if (@tools == 0);

foreach (@tools){
    if ($_ !~ /:\d+$/){
        die "$_: wrong format of tool:RSS: \n";
    }
}

my $ref_type = $ref_sv;

if ($ref_sv eq 'A'){
    $ref_sv = $ref_sv_simA;
}
elsif ($ref_sv eq 'N'){
    $ref_sv = $ref_sv_NA12878;
#    $min_overlap_ratio = 0.01 if ($sv_type eq 'DUP');
}

$min_overlap_ratio2 = 0.6 if ($ref_type eq 'A') and (($sv_size eq 'SS') or ($sv_size eq 'S'));
$min_overlap_ratio2 = 0.8 if ($ref_type eq 'A') and (($sv_size eq 'M') or ($sv_size eq 'L'));

my %dup_tool = ('AS-GENSENG' => 1, 'CNVnator' => 1, 'Control-FREEC' => 1, 'Delly' => 1, 'ERDS' => 1, 'forestSV' => 1, 'inGAP' => 1, 'laSV' => 1, 'Lumpy' => 1, 'Manta' => 1, 'Meerkat' => 1, 'metaSV' => 1, 'OncoSNP-Seq' => 1,
		'Pindel' => 1, 'RAPTR' => 1, 'readDepth' => 1, 'Sniffles' => 1, 'SoftSearch' => 1, 'SoftSV' => 1, 'SVDetect' => 1, 'Ulysses' => 1, 'TIDDIT' => 1, 'PennCNV-Seq' => 1, 'BICseq2' => 1, 'SVelter' => 1, 'Wham' => 1, 'GRIDSS' => 1, 'MATCHCLIP' => 1);
my %ins_tool = ('123SV' => 1, 'Basil' => 1, 'BreakDancer' => 1, 'BreakSeek' => 1, 'BreakSeq2' => 1, 'CLEVER' => 1, 'CREST' => 1, 'FermiKit' => 1, 'inGAP' => 1, 'laSV' => 1, 'Manta' => 1, 'Meerkat' => 1, 'metaSV' => 1, 'MELT' => 1, 
		'MindTheGap' => 1, 'Mobster' => 1, 'PBHoney' => 1, 'PBSV' => 1, 'Popins' => 1, 'PRISM' => 1, 'RAPTR' => 1, 'Sniffles' => 1, 'Socrates' => 1, 'SoftSearch' => 1, 'SVDetect' => 1, 'SVfinder' => 1, 'SVseq2' => 1, 'laSV' => 1, 'Pamir' => 1, 'Wham' => 1, 'GRIDSS' => 1, 'SvABA' => 1);

my %SDlen;
my %SDbp;

my $SD_len_file = "$script_path/SV_SDlen_list_2.txt";

open (FILE, $SD_len_file) or die ("SD_len_file is not found: $!\n");
while (my $line = <FILE>){
    chomp $line;
    my @line = split (/\s+/, $line);
    my $id = lc $line[0];
    my $class = $line[1];
    my $type = $line[2];
    my $sd_len = $line[3];
    my $sd_bp = $line[4];
    if ($type eq 'INS'){
	${${$SDlen{$type}}{'S'}}{$id} = $sd_len;
	${${$SDbp{$type}}{'S'}}{$id} = $sd_bp;
	${${$SDlen{$type}}{'M'}}{$id} = $sd_len;
	${${$SDbp{$type}}{'M'}}{$id} = $sd_bp;
	${${$SDlen{$type}}{'L'}}{$id} = $sd_len;
	${${$SDbp{$type}}{'L'}}{$id} = $sd_bp;
    }
    else{
	${${$SDlen{$type}}{$class}}{$id} = $sd_len;
	${${$SDbp{$type}}{$class}}{$id} = $sd_bp;
    }
    if (($type eq 'DEL') or ($type eq 'INV')){
	if ($class eq 'M'){
	    ${${$SDlen{$type}}{'L'}}{$id} = $sd_len;
	    ${${$SDbp{$type}}{'L'}}{$id} = $sd_bp;
	}
    }
}
close (FILE);

my %gap;

my $gap_bed = "$script_path/../Ref_SV/gap.bed";

open (FILE, $gap_bed) or die "$gap_bed is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    my @line = split (/\s+/, $line);
    my $chr = $line[0];
    my $pos = $line[1];
    my $end = $line[2];
    ${$gap{$chr}}{$pos} = $end;
}
close (FILE);

my $call_ctx_num = 0;
my $call_ctx_s = 0;
my $call_ctx_m = 0;
my $call_ctx_l = 0;

#my %tool_set;
my %tool_single;
my @tool_set;
my %var_file;
my %var_read;
my @var_file;

my %call;
my %sv_read;
my %match;
my %call_count;
my %match_count;
my %dup_flag;
my @var_id2 = ();

my @work_files = <$input_dir/*.vcf>;
my @work_files2;
foreach (@work_files){
    push @work_files2, $_ if ($_ !~ /\.TP-FP\.vcf$|\.FP\.vcf$|\.FN\.vcf$/);
}

if (@tools > 0){
    $eval_file = "$out_prefix.tool.list" if ($out_prefix ne '');
    $eval_file = "$sv_type.$sv_size.tool.list" if ($out_prefix eq '');
    my $count_1 = 0;
    my @tool_comb;
    my @tool_comb2;
    my @tool_comb3;
    foreach my $tool_1 (@tools){
	push @tool_comb, "$tool_1=$tool_1";
    }
    foreach my $tool_1 (@tools){
	$count_1 ++;
	my $count_2 = 0;
	foreach my $tool_2 (@tools){
	    $count_2 ++;
	    next if ($count_2 <= $count_1);
	    my $set = "$tool_1=$tool_2";
	    push @tool_comb, $set;
	}
    }
    if (($merge_2set == 0) and ($merge_3set == 0)){
	open (OUT, "> $eval_file");
	foreach my $set (@tool_comb){
	    print OUT "$set\n";
	}
	close (OUT);
    }
    elsif (($merge_2set == 1) or ($merge_3set == 1)){
	$count_1 = 0;
	foreach my $set1 (@tool_comb){
	    $count_1 ++;
	    my $count_2 = 0;
	    foreach my $set2 (@tool_comb){
		$count_2 ++;
		next if ($count_2 <= $count_1);
		my $set3 = "$set1~$set2";
		push @tool_comb2, $set3;
	    }
	}
	if ($merge_2set == 1){
	    open (OUT, "> $eval_file");
	    foreach my $set (@tool_comb2){
		print OUT "$set\n";
	    }
	    close (OUT);
	}
    }
    if ($merge_3set == 1){
	$count_1 = 0;
	foreach my $set1 (@tool_comb2){
	    foreach my $set2 (@tool_comb){
		next if ($set1 =~ $set2);
		my $set3 = "$set1~$set2";
		push @tool_comb3, $set3;
	    }
	}
	open (OUT, "> $eval_file");
	foreach my $set (@tool_comb3){
	    print OUT "$set\n";
	}
	close (OUT);
    }
}

$eval_file =~ s/\'//g if ($eval_file =~ /\'/);


open (FILE, $eval_file) or die "$eval_file is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    next if ($line =~ /^#/);
    next if ($line =~ /^$/);
    my $set = $line;
    $set =~ s/~/|/g if ($set =~ /~/);
    my @pairs = split (/\|/, $set);
    push @tool_set, $set;
    foreach my $pair (@pairs){
        my ($id1, $id2) = ('', '');
        ($id1, $id2) = split (/=/, $pair) if ($pair =~ /=/);
        $id1 = $pair if ($pair !~ /=/);
        my ($id1_base, $read1) = split (/:/, $id1);
        ${$var_read{$id1_base}}{$read1} = 1;
        if (!exists $var_file{$id1_base}){
            my $exist_flag = 0;
            foreach my $file (@work_files2){
                if (($file =~ /\/$id1_base\./i) and ($file !~ /=|~/)){
                    $var_file{$id1_base} = $file;
                    $exist_flag = 1;
                    last;
                }
            }
            if ($exist_flag == 0){
                die "vcf file for $id1_base is not found:\n";
            }
        }
        if ($id2 ne ''){
            my ($id2_base, $read2) = split (/:/, $id2);
            ${$var_read{$id2_base}}{$read2} = 1;
            if (!exists $var_file{$id2_base}){
                my $exist_flag = 0;
                foreach my $file (@work_files2){
                    if (($file =~ /\/$id2_base\./i) and ($file !~ /=|~/)){
                        $var_file{$id2_base} = $file;
                        $exist_flag = 1;
                        last;
                    }
                }
                if ($exist_flag == 0){
                    die "vcf file for $id2_base is not found:\n";
                }
            }
        }
        else{
            $tool_single{$pair} = 1;
        }
    }
}
close (FILE);


my %ref;
my $ref_del_num = 0;
my $ref_ins_num = 0;
my $ref_inv_num = 0;
my $ref_dup_num = 0;

my $min_ref_len = 30;
my $max_ref_len = 2000000;

if ($sv_size eq 'SS'){
    $max_ref_len = 150;
}
elsif ($sv_size eq 'S'){
    $min_ref_len = 50;
    $max_ref_len = 1100;
}
elsif ($sv_size eq 'M'){
    $min_ref_len = 900;
    $max_ref_len = 105000;
}
elsif ($sv_size eq 'L'){
    $min_ref_len = 95000;
}

open (FILE, $ref_sv) or die "$ref_sv is not found: $!\n";
while (my $line = <FILE>){
    chomp $line;
    next if ($line =~ /^#/);
    my @line = split (/\t/, $line);
    my $chr = $line[0];
    next if ($target_chr ne 'all') and (($chr ne $target_chr) and ($target_chr !~ /,$chr,|,$chr$|^$chr,/));
    my $pos = $line[1];
    my $type = $line[2];
#    $type = 'DEL' if ($type eq 'INDEL');
    $type = 'DUP' if ($type eq 'tandem');
    my $svlen = 0;
    $svlen = $1 if ($line[7] =~ /SVLEN=-*(\d+)/);
#    next if ($svlen < $min_ref_len) and ($type ne 'INS');
#    next if ($svlen > $max_ref_len);
    if ($type eq 'DEL'){
	if ($sv_size eq 'SS'){
	    $ref_del_num ++ if ($svlen <= 100);
	}
	elsif ($sv_size eq 'S'){
	    $ref_del_num ++ if ($svlen > 100) and ($svlen <= 1000);
	}
	elsif ($sv_size eq 'M'){
	    $ref_del_num ++ if ($svlen > 1000) and ($svlen <= 100000);
	}
	elsif ($sv_size eq 'L'){
	    $ref_del_num ++ if ($svlen > 100000);
	}
	else{
	    $ref_del_num ++;
	}
    }
    elsif ($type ne 'INS'){
	if ($sv_size eq 'S'){
	    $ref_dup_num ++ if ($svlen <= 1000);
	    $ref_inv_num ++ if ($svlen <= 1000);
	}
	elsif ($sv_size eq 'M'){
	    $ref_dup_num ++ if ($svlen > 1000) and ($svlen <= 100000);
	    $ref_inv_num ++ if ($svlen > 1000) and ($svlen <= 100000);
	}
	elsif ($sv_size eq 'L'){
	    $ref_dup_num ++ if ($svlen > 100000);
	    $ref_inv_num ++ if ($svlen > 100000);
	}
	else{
	    $ref_dup_num ++;
	    $ref_inv_num ++;
	}
    }
    $ref_ins_num ++ if ($type eq 'INS');
    $type = 'DUP' if ($type eq 'INS-DUP');
    my $end = $pos + $svlen;
    my $gap_overlap = 0;
    foreach my $gstart (sort {$a <=> $b} keys %{$gap{$chr}}){
	my $gend = ${$gap{$chr}}{$gstart};
	if (($pos >= $gstart) and ($pos <= $gend)){
	    if ($type eq 'INS'){
		$gap_overlap = 1;
		last;
	    }
	    else{
		if ($gend - $pos + 1 >= $svlen * 0.5){
		    $gap_overlap = 1;
		    last;
		}
	    }
	}
	elsif (($type ne 'INS') and ($gstart >= $pos) and ($gstart <= $end)){
	    if ($end - $gstart + 1 >= $svlen * 0.5){
		$gap_overlap = 1;
		last;
	    }
	}
	last if ($gstart > $end);
    }
    if ($gap_overlap == 1){
	next;
    }
    ${${$ref{$type}}{$chr}}{$pos} = $svlen;
}
close (FILE);


foreach my $id (keys %var_file){
    my $var_file = $var_file{$id};
    my %pre_info;
    my %overlap;
    my %match_ref;
    $overlap{'DEL'} = 0;
    $overlap{'DUP'} = 0;
    $overlap{'INV'} = 0;
    $overlap{'INS'} = 0;
    $overlap{'TRA'} = 0;
    foreach my $min_read (sort {$a <=> $b} keys %{$var_read{$id}}){
	my $id2 = "$id:$min_read";
	push @var_id2, $id2;
	open (FILE, $var_file) or die "$var_file is not found: $!\n";
	while (my $line = <FILE>){
	    chomp $line;
	    next if ($line =~ /^#/);
	    my @line = split (/\t/, $line);
	    my $chr = $line[0];
	    next if ($chr !~ /^\d+$|[XY]/);
	    next if ($target_chr ne 'all') and (($chr ne $target_chr) and ($target_chr !~ /,$chr,|,$chr$|^$chr,/));
	    my $pos = $line[1];
	    my $type = $1 if ($line[7] =~ /SVTYPE=(.+?);/);
		$type = 'INS' if ($type =~ /MEI|NUMT|VEI/);
	    if ($sv_type ne 'ALL'){
		next if ($type ne $sv_type);
	    }
	    my $len = 0;
	    $len = $1 if ($line[7] =~ /SVLEN=-*(\d+)/);
	    next if ($type eq 'INV') and ($len > $max_inv_size);
	    if (($type eq 'DEL') or ($type eq 'DUP') or ($type eq 'INV')){
		if ($sv_size eq 'SS'){
		    next if ($len > 100);
		}
		elsif ($sv_size eq 'S'){
		    next if ($len > 1000);
		    next if ($len < 100);
		}
		elsif ($sv_size eq 'M'){
		    next if ($len < 1000);
		    next if ($len > 100000);
		}
		elsif ($sv_size eq 'Lo'){
		    next if ($len < 500);
		}
		elsif ($sv_size eq 'L'){
		    next if ($len < 100000);
		}
	    }
	    my $bplen = 0;
	    $bplen = $1 if ($line[7] =~ /BPSIZE=(\d+);/);
	    my $end = 0;
	    if ($bplen > 0){
		$end = $pos + $bplen - 1;
	    }
	    else{
		$end = $pos + $len - 1;
	    }
	    my $gap_overlap = 0;
	    foreach my $gstart (sort {$a <=> $b} keys %{$gap{$chr}}){
		my $gend = ${$gap{$chr}}{$gstart};
		if (($pos >= $gstart) and ($pos <= $gend)){
		    if ($type eq 'INS'){
			$gap_overlap = 1;
			last;
		    }
		    else{
			if ($gend - $pos + 1 >= $len * 0.5){
			    $gap_overlap = 1;
			    last;
			}
		    }
		}
		elsif (($type ne 'INS') and ($gstart >= $pos) and ($gstart <= $end)){
		    if ($end - $gstart + 1 >= $len * 0.5){
			$gap_overlap = 1;
			last;
		    }
		}
		last if ($gstart > $end);
	    }
	    if ($gap_overlap == 1){
		next;
	    }
	    
	    ${$call_count{$id2}}{$type} = 0 if (!exists ${$call_count{$id2}}{$type});
	    my $reads = 3;
	    $reads = $1 if ($line[7] =~ /READS=(\d+)/);
	    next if ($reads < $min_read);
	    my $chr2 = '';
	    my $pos2 = 0;
	    if ($type eq 'TRA'){
		$chr2 = $1 if ($line[8] =~ /CHR2=(.+?);/);
		$pos2 = $1 if ($line[8] =~ /POS2=(\d+)/);
		$end = 0;
		$len = 0;
	    }
	    next if ($len < $min_sv_len) and ($len > 0) and ($type ne 'INS') and ($type ne 'TRA');
	    next if ($len > $max_sv_len);
	    my ($pre_chr, $pre_pos, $pre_size, $pre_hit) = ('', 0, 0, 0);
	    ($pre_chr, $pre_pos, $pre_size, $pre_hit) = split (/=/, $pre_info{$type}) if (exists $pre_info{$type});
	    if (($type eq 'INS') and ($pre_chr eq $chr) and ($pos - $pre_pos < $var_sd)){
		if ((($len > 0) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)) or ($len == 0)){
		    $overlap{$type} ++;
		    if ($pre_hit == 1){
			$pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
			next;
		    }
		}
	    }
	    elsif (($type ne 'INS') and ($pre_chr eq $chr) and ($pre_pos + $pre_size - $pos > $len * 0.8) and ($pre_pos + $pre_size - $pos > $pre_size * 0.8) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)){
		$overlap{$type} ++;
		if ($pre_hit == 1){
		    $pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
		    next;
		}
	    }
	    elsif (($type eq 'TRA') and ($pre_chr eq $chr) and ($pos - $pre_pos < $min_ctx)){
		$overlap{$type} ++;
		if ($pre_hit == 1){
		    $pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
		    next;
		}
	    }
	    else{
		${${${$call{$id2}}{$type}}{$chr}}{$pos} = $len if ($type ne 'TRA');
		${${${$call{$id2}}{$type}}{$chr}}{$pos} = "$chr2=$pos2" if ($type eq 'TRA');
		${${${$sv_read{$id2}}{$type}}{$chr}}{$pos} = $reads;
		${$call_count{$id2}}{$type} ++;
	    }
	}
    }
}

my %call_share_2;

my %result_2p;

my %max_or;
my %max_and;
my %sv_and;
my %sv_and_or;
my %sv_and_or_or;

my %dup_and_flag;

my %classify_1;
my %classify_2;

foreach my $id1 (keys %call_count){
    my ($id2, $min_read) = split (/:/, $id1);
    foreach my $type (keys %{$call_count{$id1}}){
	if (exists $tool_single{$id1}){
	    foreach my $chr (keys %{${$call{$id1}}{$type}}){
		foreach my $pos (keys %{${${$call{$id1}}{$type}}{$chr}}){
		    my $len = ${${${$call{$id1}}{$type}}{$chr}}{$pos} if ($type ne 'TRA');
		    my ($chr2, $pos_tra) = split (/=/, ${${${$call{$id1}}{$type}}{$chr}}{$pos}) if ($type eq 'TRA');
		    ${${${$sv_and{$type}}{$id1}}{$chr}}{$pos} = "$pos|$len" if ($type ne 'TRA');
		    ${${${$sv_and{$type}}{$id1}}{$chr}}{$pos} = "$chr2|$pos|$pos_tra" if ($type eq 'TRA');
		}
	    }
	}
    }
}

my $eval_out = '';
$eval_out = "$out_prefix.$ref_type.overlap.eval.txt" if ($out_prefix ne '');
open (OUT, "> $eval_out") if ($eval_out ne '');
if ($eval_out eq ''){
    print "# Type (Size)\tRecall(%)\tPrecision(%)\tNumber of overlapping calls\n";
}
else{
    print OUT "# Type (Size)\tRecall(%)\tPrecision(%)\tNumber of overlapping calls\n";
}

foreach my $set (@tool_set){
    my %vcf;
    my $set2 = $set;
    $set2 =~ s/\|/~/g;
    if ($set2 !~ /~/){
	my ($id1, $id2) = split (/=/, $set2);
	if ($id1 eq $id2){
	    $set2 = $id1;
	}
    }
    if ($eval_out eq ''){
        print "# $set2 #\n";
    }
    else{
        print OUT "# $set2 #\n";
    }
    my $overlap_vcf = '';
    if (($output_vcf == 1) and ($set2 =~ /=/)){
        my $set3 = $set2;
        $set3 =~ s/:\d+//g;
        $overlap_vcf = "$out_prefix.$set3.vcf" if ($out_prefix ne '');
        $overlap_vcf = "$set3.vcf" if ($out_prefix eq '');
        open (OUT2, "> $overlap_vcf");
    }
    my %call_share;
    %sv_and_or = ();
    %sv_and_or_or = ();
    my %pair;
    $set =~ s/^\.\/// if ($set =~ /^\.\//);
    my @pairs = split (/\|/, $set);
    my $count = 0;
    map{$pair{$_} = 1} @pairs;
    foreach my $pair (@pairs){
	my ($id1, $id2) = ('', '');
	($id1, $id2) = split (/=/, $pair) if ($pair =~ /=/);
	$id1 = $pair if ($pair !~ /=/);
	my ($id1_base, $min_read1) = split (/:/, $id1);
	my ($id2_base, $min_read2) = split (/:/, $id2);
	foreach my $type (keys %{$call{$id1}}){
	    if (($id2 ne '') and (exists ${$call{$id2}}{$type})){
		foreach my $chr (keys %{${$call{$id1}}{$type}}){
		    if (exists ${${$call{$id2}}{$type}}{$chr}){
			foreach my $pos1 (sort {$a <=> $b} keys %{${${$call{$id1}}{$type}}{$chr}}){
			    my $len1 = ${${${$call{$id1}}{$type}}{$chr}}{$pos1};
			    my $end1 = $pos1 + $len1 - 1;
			    $end1 = $pos1 if ($type eq 'INS');
			    my @match = ();
			    foreach my $pos2 (sort {$a <=> $b} keys %{${${$call{$id2}}{$type}}{$chr}}){
				last if ($pos2 > $pos1 + $ins_sd);
				my $len2 = ${${${$call{$id2}}{$type}}{$chr}}{$pos2};
				my $end2 = $pos2 + $len2 - 1;
				$end2 = $pos2 if ($type eq 'INS');
				next if ($end2 + $ins_sd < $pos1);
				my $ovlrate = 0;
				if ($type eq 'INS'){
				    if (abs ($pos1 - $pos2) <= $ins_sd){
					$ovlrate = 1 / abs ($pos1 - $pos2) if (abs ($pos1 - $pos2) > 0);
					$ovlrate = 1 if (abs ($pos1 - $pos2) == 0);
				    }
				}
				elsif ($type eq 'TRA'){
				    my ($chr1_tra, $pos1_tra) = split (/=/, ${${${$call{$id1}}{$type}}{$chr}}{$pos1});
				    my ($chr2_tra, $pos2_tra) = split (/=/, ${${${$call{$id2}}{$type}}{$chr}}{$pos2});
				    if (abs ($pos1 - $pos2) <= $ctx_sd){
					if (($chr1_tra eq $chr2_tra) and (abs ($pos1_tra - $pos2_tra) <= $ctx_sd)){
					    ${$call_share{$pair}}{$type} .= "$chr=$pos1=$pos2=$chr1_tra=$pos1_tra=$pos2_tra||";
					    last;
					}
				    }
				}
				else{
					next if ($len1 == 0) or ($len2 == 0);
				    if ((abs ($pos1 - $pos2) <= $var_sd) and (abs ($end1 - $end2) <= $var_sd)){
					if ($len1 >= $len2){
					    $ovlrate = $len2 / $len1;
					}
					else{
					    $ovlrate = $len1 / $len2;
					}
				    }
				    if (($pos1 >= $pos2) and ($pos1 <= $end2)){
					if ($end1 <= $end2){
					    if ($len1 >= $len2 * $min_overlap_ratio){
						$ovlrate = $len1 / $len2;
					    }
					}
					else{
					    my $overlen = $end2 - $pos1 + 1;
					    if (($overlen >= $len2 * $min_overlap_ratio) or ($overlen >= $len1 * $min_overlap_ratio)){
						my $ovlrate1 = $overlen / $len1;
						my $ovlrate2 = $overlen / $len2;
						if (($overlen >= $len2 * $min_overlap_ratio) and ($overlen >= $len1 * $min_overlap_ratio)){
						    $ovlrate = ($ovlrate1 + $ovlrate2) / 2;
						}
						elsif ((($len1 >= $len2) and ($len1 < $len2 * 5)) or (($len1 < $len2) and ($len2 < $len1 * 5))){
						    $ovlrate = ($ovlrate1 + $ovlrate2) / 2;
						}
					    }
					}
				    }
				    elsif (($pos2 >= $pos1) and ($pos2 <= $end1)){
					if ($end2 <= $end1){
					    if ($len2 >= $len1 * $min_overlap_ratio){
						$ovlrate = $len2 / $len1;
					    }
					}
					else{
					    my $overlen = $end1 - $pos2 + 1;
					    if (($overlen >= $len2 * $min_overlap_ratio) or ($overlen >= $len1 * $min_overlap_ratio)){
						my $ovlrate1 = $overlen / $len1;
						my $ovlrate2 = $overlen / $len2;
						if (($overlen >= $len2 * $min_overlap_ratio) and ($overlen >= $len1 * $min_overlap_ratio)){
						    $ovlrate = ($ovlrate1 + $ovlrate2) / 2;
						}
						elsif ((($len1 >= $len2) and ($len1 < $len2 * 5)) or (($len1 < $len2) and ($len2 < $len1 * 5))){
						    $ovlrate = ($ovlrate1 + $ovlrate2) / 2;
						}
					    }
					}
				    }
				}
				if ($ovlrate > 0){
				    push @match, "$pos2=$len2=$ovlrate";
				}
			    }
			    if (@match > 0){
				if (@match == 1){
				    my ($mpos, $mlen) = split (/=/, $match[0]);
				    ${$call_share{$pair}}{$type} .= "$chr=$pos1=$mpos=$len1=$mlen||";
				}
				else{
				    my $max_rate = 0;
				    my $best_pos = 0;
				    my $best_len = 0;
				    foreach (@match){
					my @info = split (/=/, $_);
					my $rate = $info[2];
					if ($rate > $max_rate){
					    $max_rate = $rate;
					    $best_pos = $info[0];
					    $best_len = $info[1];
					}
				    }
				    ${$call_share{$pair}}{$type} .= "$chr=$pos1=$best_pos=$len1=$best_len||";
				}
			    }
			}
		    }
		}
		if (!exists ${$sv_and{$type}}{$pair}){
		    foreach my $type (sort keys %{$call_share{$pair}}){
			my $call_share = 0;
			my @call_share = ();
			${$call_share{$pair}}{$type} =~ s/\|\|$// if (${$call_share{$pair}}{$type} =~ /\|\|$/);
			@call_share = split (/\|\|/, ${$call_share{$pair}}{$type});
			if ($type ne 'TRA'){
			    foreach my $info (@call_share){
				my ($chr, $pos1, $pos2, $len1, $len2) = split (/=/, $info);
				if ($type eq 'INS'){
				    $len1 = 0;
				    $len2 = 0;
				}
				my @pos = ($pos1, $pos2);
				my @len = ($len1, $len2);
				my $pos = int (($pos1 + $pos2) / 2 + 0.5);
				${${${$sv_and{$type}}{$pair}}{$chr}}{$pos} = "$pos1=$pos2|$len1=$len2";
			    }
			}
			else{
			    foreach my $info (@call_share){
				my ($chr, $pos1, $pos2, $chr2, $pos1_tra, $pos2_tra) = split (/=/, $info);
				my @pos = ($pos1, $pos2);
				my @pos_tra = ($pos1_tra, $pos2_tra);
				my $pos = int (($pos1 + $pos2) / 2 + 0.5);
				${${${$sv_and{$type}}{$pair}}{$chr}}{$pos} = "$chr2|$pos1=$pos2|$pos1_tra=$pos2_tra";
			    }
			}
		    }
		}
	    }
	}
    }

    my $first_pair = $pairs[0];
    my $second_pair = '';
    $second_pair = $pairs[1] if (@pairs >= 2);
    my $third_pair = $pairs[2] if (@pairs >= 3);
    my ($id1, $id2) = ('', '');
    my ($id3, $id4) = ('', '');
    ($id1, $id2) = split (/=/, $first_pair) if ($first_pair =~ /=/);
    $id1 = $first_pair if ($first_pair !~ /=/);
    ($id3, $id4) = split (/=/, $second_pair) if ($second_pair =~ /=/);
    $id3 = $second_pair if ($second_pair !~ /=/);
    my ($id1_base) = split (/:/, $id1);
    my ($id2_base) = split (/:/, $id2) if ($id2 ne '');
    my ($id3_base) = split (/:/, $id3) if ($id3 ne '');
    my ($id4_base) = split (/:/, $id4) if ($id4 ne '');
    my @ids;
    push @ids, $id1_base, $id3_base if ($id3 ne '');
    push @ids, $id2_base if ($id2 ne '');
    push @ids, $id4_base if ($id4 ne '');
#print STDERR "$set\t$first_pair\t$second_pair\t$third_pair\n";
    if (@pairs == 1){
	foreach my $type (keys %sv_and){
	    foreach my $pair (keys %{$sv_and{$type}}){
		next if ($pair ne $pairs[0]);
		my ($id1, $id2) = split (/=/, $pair);
		my $id1_base = $1 if ($id1 =~ /(.+):\d+/);
		my $id2_base = $1 if ($id2 =~ /(.+):\d+/);
		my $id1_lc = lc $id1_base;
		my $id2_lc = lc $id2_base;
		foreach my $chr (keys %{${$sv_and{$type}}{$pair}}){
		    foreach my $pos (sort {$a <=> $b} keys %{${${$sv_and{$type}}{$pair}}{$chr}}){
			my ($pos_g, $len_g) = split (/\|/, ${${${$sv_and{$type}}{$pair}}{$chr}}{$pos}) if ($type ne 'TRA');
			(my $chr2, $pos_g, my $pos_tra_g) = split (/\|/, ${${${$sv_and{$type}}{$pair}}{$chr}}{$pos}) if ($type eq 'TRA');
			my %tool_pos;
			my %tool_read;
			my @pos_g = split (/=/, $pos_g);
			my @len_g = split (/=/, $len_g) if ($type ne 'TRA');
			my $av_len = int (($len_g[0] + $len_g[1]) / 2 + 0.5);
			my @pos_tra_g = split (/=/, $pos_tra_g) if ($type eq 'TRA');
			my $class = 'S';
			if ($type eq 'DUP'){
			    $class = 'S' if ($av_len < 1000);
			    $class = 'M' if ($av_len >= 1000);
			    $class = 'L' if ($av_len >= 100000);
			}
			else{
			    $class = 'S' if ($av_len < 1000);
			    $class = 'M' if ($av_len >= 1000);
			}
			my $av_pos = int (($pos_g[0] + $pos_g[1]) / 2 + 0.5);
=pod
			my $id1_len = ${${$SDlen{$type}}{$class}}{$id1_lc};
			my $id2_len = ${${$SDlen{$type}}{$class}}{$id2_lc};
			my $id1_bp = ${${$SDbp{$type}}{$class}}{$id1_lc};
			my $id2_bp = ${${$SDbp{$type}}{$class}}{$id2_lc};
			my $pos_c = 0;
			my $len_c = 0;
			my $pos_tra_c = 0;
			if (($id1_bp <= 50) and ($id2_bp <= 50)){
			    $pos_c = $pos;
			}
			else{
			    $pos_c = $pos_g[0] if ($id1_bp <= $id2_bp);
			    $pos_c = $pos_g[1] if ($id1_bp > $id2_bp);
			}
			$len_c = $len_g[0] if ($id1_len <= $id2_len);
			$len_c = $len_g[1] if ($id1_len > $id2_len);
			if ($type eq 'TRA'){
			    $pos_tra_c = $pos_tra_g[0] if ($id1_len <= $id2_len);
			    $pos_tra_c = $pos_tra_g[1] if ($id1_len > $id2_len);
			}
=cut			
			my $read_1 = ${${${$sv_read{$id1}}{$type}}{$chr}}{$pos_g[0]};
			my $read_2 = ${${${$sv_read{$id2}}{$type}}{$chr}}{$pos_g[1]};
			my $ave_read = int ($read_1 + $read_2 / 2 + 0.5);
			my $info = "$id1_base-$pos_g[0],$id2_base-$pos_g[1]";
			${$vcf{$chr}}{$av_pos} = "$chr\t$av_pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;SVLEN=$av_len;READS=$ave_read;POS=$pos_g\tTOOLS=$info" if ($type ne 'TRA');
#			${$vcf{$chr}}{$av_pos} = "$chr\t$av_pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;READS=$ave_read;CHR2=$chr2;POS2=$pos_tra_c\tTOOLS=$info" if ($type eq 'TRA');
		    }
		}
	    }
	}
=pod
	my $out = $set;
	$out =~ s/\|/~/g;
	my $out_file = "$out.$sv_type.$sv_size.vcf";
	open (OUT, "> $out_file");
	print OUT "##fileformat=VCF\n";
	print OUT "##INFO=<ID>=SVTYPE,SV-type:DEL,DUP,INS,INV,TRA\n";
	print OUT "##INFO=<ID>=SVLEN,SV-length\n";
	print OUT "##INFO=<ID>=READS,Number-of-supporting-reads\n";
	print OUT "##INFO=<ID>=CHR2,Chromosome-of-Translocated-SV\n";
	print OUT "##INFO=<ID>=POS2,Position-of-Translocated-SV\n";
	print OUT "##FORMAT=<ID>=TOOLS,used-tools-called-positions\n";
	print OUT "#CHROM\tPOS\tID\tREFtALT\tQUAL\tFILTER\tINFO\tFORMAT\n";
	foreach my $chr (sort keys %vcf){
	    foreach my $pos (sort {$a <=> $b} keys %{$vcf{$chr}}){
		print OUT ${$vcf{$chr}}{$pos}, "\n";
	    }
	}
	close (OUT);
=cut
    }
    elsif (@pairs == 2){
	&merge_sv2 ($sv_type, $first_pair, $second_pair) if ($sv_type ne 'TRA');
	&merge_tra2 ($sv_type, $first_pair, $second_pair) if ($sv_type eq 'TRA');
	foreach my $type (keys %sv_and_or){
	    foreach my $pair (keys %{$sv_and_or{$type}}){
		foreach my $chr (keys %{${$sv_and_or{$type}}{$pair}}){
		    foreach my $pos (keys %{${${$sv_and_or{$type}}{$pair}}{$chr}}){
			my ($pair_g, $pos_g, $len_g, $len_c) = split (/\|/, ${${${$sv_and_or{$type}}{$pair}}{$chr}}{$pos}) if ($type ne 'TRA');
			($pair_g, my $chr2, $pos_g, my $pos_tra_g, my $pos_tra_c) = split (/\|/, ${${${$sv_and_or{$type}}{$pair}}{$chr}}{$pos}) if ($type eq 'TRA');
			my %tool_pos;
			my %tool_read;
			$pair_g =~ s/~/=/g;
			my @pair_g = split (/=/, $pair_g);
			my @pos_g = split (/=/, $pos_g);
			my $count = 0;
			foreach my $tool (@pair_g){
			    my $pos2 = $pos_g[$count];
			    my $read = 0;
			    $read = ${${${$sv_read{$tool}}{$type}}{$chr}}{$pos2} if (exists ${${${$sv_read{$tool}}{$type}}{$chr}}{$pos2});
#print STDERR "$tool\t$type\t$chr\t$pos\n" if (!exists ${${${$sv_read{$tool}}{$type}}{$chr}}{$pos2});
			    $tool = $1 if ($tool =~ /(.+):\d+$/);
			    $tool_pos{$tool} = $pos2;
			    $tool_read{$tool} = $read;
			    $count ++;
			}
			my $sum_read = 0;
			my $count_read = 0;
			foreach my $tool (sort keys %tool_read){
			    $sum_read += $tool_read{$tool};
			    $count_read ++;
			}
			my $ave_read = int ($sum_read / $count_read + 0.5);
			my $info = '';
			foreach my $tool (sort keys %tool_pos){
			    $info .= "$tool-$tool_pos{$tool}" . ',';
			}
			$info =~ s/,$//;
			${$vcf{$chr}}{$pos} = "$chr\t$pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;SVLEN=$len_c;READS=$ave_read\tTOOLS=$info" if ($type ne 'TRA');
			${$vcf{$chr}}{$pos} = "$chr\t$pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;READS=$ave_read;CHR2=$chr2;POS2=$pos_tra_c\tTOOLS=$info" if ($type eq 'TRA');
		    }
		}
	    }
	}
=pod
	my $out = $set;
	$out =~ s/\|/~/g;
	my $out_file = "$out.$sv_type.$sv_size.vcf";
	open (OUT, "> $out_file");
	print OUT "##fileformat=VCF\n";
	print OUT "##INFO=<ID>=SVTYPE,SV_type:DEL,DUP,INS,INV,TRA\n";
	print OUT "##INFO=<ID>=SVLEN,SV_length\n";
	print OUT "##INFO=<ID>=READS,Number_of_supporting_reads\n";
	print OUT "##INFO=<ID>=CHR2,Chromosome_of_Translocated_SV\n";
	print OUT "##INFO=<ID>=POS2,Position_of_Translocated_SV\n";
	print OUT "##FORMAT=<ID>=TOOLS,used_tools-called_positions\n";
	print OUT "#CHROM\tPOS\tCLASS\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\n";
	foreach my $chr (sort keys %vcf){
	    foreach my $pos (sort {$a <=> $b} keys %{$vcf{$chr}}){
		print OUT ${$vcf{$chr}}{$pos}, "\n";
	    }
	}
	close (OUT);
=cut
    }
    elsif (@pairs == 3){
	&merge_sv2 ($sv_type, $first_pair, $second_pair) if ($sv_type ne 'TRA');
	&merge_tra2 ($sv_type, $first_pair, $second_pair) if ($sv_type eq 'TRA');
	my ($id5, $id6) = ('', '');
	($id5, $id6) = split (/=/, $third_pair) if ($third_pair =~ /=/);
	$id5 = $third_pair if ($third_pair !~ /=/);
	my ($id5_base) = split (/:/, $id5);
	my ($id6_base) = split (/:/, $id6) if ($id6 ne '');
	my $pair4 = "$first_pair~$second_pair";
	&merge_sv3 ($sv_type, $pair4, $third_pair) if ($sv_type ne 'TRA');
	&merge_tra3 ($sv_type, $pair4, $third_pair) if ($sv_type eq 'TRA');
	
	foreach my $type (keys %sv_and_or_or){
	    foreach my $pair (keys %{$sv_and_or_or{$type}}){
		foreach my $chr (keys %{${$sv_and_or_or{$type}}{$pair}}){
		    foreach my $pos (keys %{${${$sv_and_or_or{$type}}{$pair}}{$chr}}){
			my ($pair_g, $pos_g, $len_g, $len_c) = split (/\|/, ${${${$sv_and_or_or{$type}}{$pair}}{$chr}}{$pos}) if ($type ne 'TRA');
			($pair_g, my $chr2, $pos_g, my $pos_tra_g, my $pos_tra_c) = split (/\|/, ${${${$sv_and_or_or{$type}}{$pair}}{$chr}}{$pos}) if ($type eq 'TRA');
			my %tool_pos;
			my %tool_read;
			$pair_g =~ s/~/=/g;
			my @pair_g = split (/=/, $pair_g);
			my @pos_g = split (/=/, $pos_g);
			my $count = 0;
			foreach my $tool (@pair_g){
			    my $pos2 = $pos_g[$count];
			    my $read = ${${${$sv_read{$tool}}{$type}}{$chr}}{$pos2};
			    $tool = $1 if ($tool =~ /(.+):\d+$/);
			    $tool_pos{$tool} = $pos2;
			    $tool_read{$tool} = $read;
			    $count ++;
			}
			my $sum_read = 0;
			my $count_read = 0;
			foreach my $tool (sort keys %tool_read){
			    $sum_read += $tool_read{$tool};
			    $count_read ++;
			}
			my $ave_read = int ($sum_read / $count_read + 0.5);
			my $info = '';
			foreach my $tool (sort keys %tool_pos){
			    $info .= "$tool-$tool_pos{$tool}" . ',';
			}
			$info =~ s/,$//;
			${$vcf{$chr}}{$pos} = "$chr\t$pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;SVLEN=$len_c;READS=$ave_read\tTOOLS=$info" if ($type ne 'TRA');
			${$vcf{$chr}}{$pos} = "$chr\t$pos\t$type\t.\t.\t.\tPASS\tSVTYPE=$type;READS=$ave_read;CHR2=$chr2;POS2=$pos_tra_c\tTOOLS=$info" if ($type eq 'TRA');
		    }
		}
	    }
	}
=pod
	my $out = $set;
	$out =~ s/\|/~/g;
	my $out_file = "$out.$sv_type.$sv_size.vcf";
	open (OUT, "> $out_file");
	print OUT "##fileformat=VCF\n";
	print OUT "##INFO=<ID>=SVTYPE,SV_type:DEL,DUP,INS,INV,TRA\n";
	print OUT "##INFO=<ID>=SVLEN,SV_length\n";
	print OUT "##INFO=<ID>=READS,Number_of_supporting_reads\n";
	print OUT "##INFO=<ID>=CHR2,Chromosome_of_Translocated_SV\n";
	print OUT "##INFO=<ID>=POS2,Position_of_Translocated_SV\n";
	print OUT "##FORMAT=<ID>=TOOLS,used_tools-called_positions\n";
	print OUT "#CHROM\tPOS\tCLASS\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\n";
	foreach my $chr (sort keys %vcf){
	    foreach my $pos (sort {$a <=> $b} keys %{$vcf{$chr}}){
		print OUT ${$vcf{$chr}}{$pos}, "\n";
	    }
	}
	close (OUT);
=cut
    }
    my %match_ref;
    my %pre_info;
    my %overlap;
    $overlap{'DEL'} = 0;
    $overlap{'DUP'} = 0;
    $overlap{'INV'} = 0;
    $overlap{'INS'} = 0;
    
    my $call_del_num = 0;
    my $call_ins_num = 0;
    my $call_inv_num = 0;
    my $call_dup_num = 0;
    my $match_del_num = 0;
    my $match_ins_num = 0;
    my $match_inv_num = 0;
    my $match_dup_num = 0;
    
    my $uncall_dup_num = 0;
    my $uncall_ins_num = 0;
    my $recal_del_num = 0;
    my $recal_dup_num = 0;
    
    my $under_del_ref = 0;
    my $over_del_ref = 0;
    my $sum_under_ref = 0;
    
    foreach my $chr (sort keys %vcf){
	foreach my $pos (sort {$a <=> $b} keys %{$vcf{$chr}}){
	    my $len = 0;
	    $len = $1 if (${$vcf{$chr}}{$pos} =~ /SVLEN=(\d+)/);
	    my $type = $1 if (${$vcf{$chr}}{$pos} =~ /SVTYPE=(.+?);/);
	    my $end = $pos + $len;
	    my ($pre_chr, $pre_pos, $pre_size, $pre_hit) = ('', 0, 0, 0);
	    ($pre_chr, $pre_pos, $pre_size, $pre_hit) = split (/=/, $pre_info{$type}) if (exists $pre_info{$type});
	    if (($type eq 'INS') and ($pre_chr eq $chr) and ($pos - $pre_pos < $var_sd)){
		if ((($len > 0) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)) or ($len == 0)){
		    $overlap{$type} ++;
		    if ($pre_hit == 1){
			$pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
			next;
		    }
		}
	    }
	    elsif (($type ne 'INS') and ($pre_chr eq $chr) and ($pre_pos + $pre_size - $pos > $len * 0.8) and ($pre_pos + $pre_size - $pos > $pre_size * 0.8) and ($pre_size > $var_sd * 0.5) and ($len > $var_sd * 0.5)){
		$overlap{$type} ++;
		if ($pre_hit == 1){
		    $pre_info{$type} = "$chr=$pos=$len=1" if ($pos + $len > $pre_pos + $pre_size);
		    next;
		}
	    }
	    else{
		$call_del_num ++ if ($type eq 'DEL');
		$call_dup_num ++ if ($type eq 'DUP');
		$call_ins_num ++ if ($type eq 'INS');
		$call_inv_num ++ if ($type eq 'INV');
	    }
            my $size = 'S';
            if ($type ne 'INS'){
                if ($len <= 1000){
                    $size = 'S';
                    if (($len <= 100) and ($type eq 'DEL')){
                        $size = 'SS';
                    }
                }
                elsif (($len > 1000) and ($len <= 100000)){
                    $size = 'M';
                }
                elsif ($len > 100000){
                    $size = 'L';
                }
            }
            if ($ref_sv eq $ref_sv_simA){
                $min_overlap_ratio2 = 0.8  if ($size eq 'M') or ($size eq 'L');
                $min_overlap_ratio2 = 0.6  if ($size eq 'SS') or ($size eq 'S');
            }

	    my $ins_flag = 0;
	    my $dup_flag = 0;
	    my $tool_str = $1 if (${$vcf{$chr}}{$pos} =~ /TOOLS=(\S+)/);
	    my @tool_pos = split (/,/, $tool_str);
	    foreach (@tool_pos){
		my ($tool) = split (/-/, $_);
		$ins_flag = 1 if (exists $ins_tool{$tool});
		$dup_flag = 1 if (exists $dup_tool{$tool});
	    }

	    my $flag = 0;
	    my $hit_len = 0;
            my $hit_bp = 0;
	    if ($type eq 'DEL'){
		my $dellen = 0;
		foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DEL'}}{$chr}}){
		    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
		    $dellen = ${${$ref{'DEL'}}{$chr}}{$bp};
		    my $delend = $bp + $dellen - 1;
		    $hit_bp = $bp;
		    $hit_len = $dellen;
		    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $delend) <= $var_sd)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		    if (($pos >= $bp) and ($pos <= $delend)){
			if ($end <= $delend){
			    if ($len >= $dellen * $min_overlap_ratio2){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($delend - $pos >= $dellen * $min_overlap_ratio2) and ($delend - $pos >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		    elsif (($bp >= $pos) and ($bp <= $end)){
			if ($delend <= $end){
			    if ($dellen >= $len * $min_overlap_ratio2){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($end - $bp >= $dellen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		}
	    }
	    elsif ($type eq 'DUP'){
		my $duplen = 0;
		foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DUP'}}{$chr}}){
		    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
		    $duplen = ${${$ref{'DUP'}}{$chr}}{$bp};
		    my $dupend = $bp + $duplen - 1;
		    $hit_bp = $bp;
		    $hit_len = $duplen;
		    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $dupend) <= $var_sd)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		    if (($pos >= $bp) and ($pos <= $dupend)){
			if ($end <= $dupend){
			    if ($len >= $duplen * $min_overlap_ratio2){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($dupend - $pos >= $duplen * $min_overlap_ratio2) and ($dupend - $pos >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		    elsif (($bp >= $pos) and ($bp <= $end)){
			if ($dupend <= $end){
			    if ($duplen >= $len * $min_overlap_ratio2){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($end - $bp >= $duplen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		}
		if (($flag == 0) and ($ins_flag == 0)){
			foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INS'}}{$chr}}){
			    last if ($bp > $end + $len);
			    next if (exists ${${$match_ref{'INS'}}{$chr}}{$bp});
			    my $inslen = ${${$ref{'INS'}}{$chr}}{$bp};
			    next if ($inslen < $min_sv_len);
			    my $insend = $bp + $inslen - 1;
			    if (($pos <= $bp) and ($end >= $insend)){
				if ($inslen >= $len * $min_overlap_ratio2){
				    $flag = 2;
				    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
				    last;
				}
			    }
			    elsif (($pos >= $bp) and ($end <= $insend)){
				if ($len >= $inslen * $min_overlap_ratio2){
				    $flag = 2;
				    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
				    last;
				}
			    }
			    elsif (($pos >= $bp) and ($pos <= $insend)){
				my $overlap = $insend - $pos + 1;
				if (($overlap >= $len * $min_overlap_ratio2) and ($overlap >= $inslen * $min_overlap_ratio2)){
				    $flag = 2;
				    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
				    last;
				}
			    }
			    elsif (($end >= $bp) and ($end <= $insend)){
				my $overlap = $end - $bp + 1;
				if (($overlap >= $len * $min_overlap_ratio2) and ($overlap >= $inslen * $min_overlap_ratio2)){
				    $flag = 2;
				    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
				    last;
				}
			    }
			    if ($flag == 0){
				if (abs ($end - $bp) <= $ins_sd){
				    if (($len >= $inslen) and ($inslen >= $len * $min_overlap_ratio2)){
					$flag = 2;
					${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
					last;
				    }
				    elsif (($inslen > $len) and ($len >= $inslen * $min_overlap_ratio2)){
					$flag = 2;
					${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
					last;
				    }
				}
			    }
			}
		    }
=pod
		if (($flag == 0) and ($ins_flag == 0)){
		    foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INS'}}{$chr}}){
			next if (exists ${${$match_ref{'INS'}}{$chr}}{$bp});
			my $inslen = ${${$ref{'INS'}}{$chr}}{$bp};
			if (abs ($pos - $bp) <= $ins_sd){
			    $ref_dup_num ++;
			    $flag = 1;
			    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
			    last;
			}
			if (($flag == 0) and ($len > 0) and ($inslen > $min_sv_len)){
			    if ((($pos >= $bp) and ($pos <= $bp + $inslen - 1)) or (($bp >= $pos) and ($bp <= $end))){
				if ((($len >= $inslen) and ($len >= $inslen * $min_overlap_ratio2)) or (($len < $inslen) and ($inslen >= $len * $min_overlap_ratio2))){
				    $flag = 1;
				    $ref_dup_num ++;
				    ${${$match_ref{'INS'}}{$chr}}{$bp} = 1;
				    last;
				}
			    }
			}
		    }
		}
=cut
	    }
	    elsif ($type eq 'INS'){
		my $duplen = 0;
		foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INS'}}{$chr}}){
		    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
		    $duplen = ${${$ref{'INS'}}{$chr}}{$bp};
		    $hit_bp = $bp;
		    my $dupend = $bp + $duplen - 1;
		    if (abs ($pos - $bp) <= $ins_sd){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
		    }
		    last if ($flag > 0);
		}
		if (($flag == 0) and ($dup_flag == 0)){
		    foreach my $bp (sort {$a <=> $b} keys %{${$ref{'DUP'}}{$chr}}){
			next if (exists ${${$match_ref{'DUP'}}{$chr}}{$bp});
			$duplen = ${${$ref{'DUP'}}{$chr}}{$bp};
			my $dupend = $bp + $duplen - 1;
			if ((abs ($pos - $bp) <= $ins_sd) or (abs ($pos - $dupend) <= $ins_sd)){
			    $flag = 2;
			    ${${$match_ref{'DUP'}}{$chr}}{$bp} = 1;
			}
			last if ($flag > 0);
		    }
		}
	    }
	    elsif ($type eq 'INV'){
		my $invlen = 0;
		foreach my $bp (sort {$a <=> $b} keys %{${$ref{'INV'}}{$chr}}){
		    next if (exists ${${$match_ref{$type}}{$chr}}{$bp});
		    $invlen = ${${$ref{'INV'}}{$chr}}{$bp};
		    my $invend = $bp + $invlen - 1;
		    $hit_bp = $bp;
		    $hit_len = $invlen;
		    if ((abs ($pos - $bp) <= $var_sd) and (abs ($end - $invend) <= $var_sd)){
			$flag = 1;
			${${$match_ref{$type}}{$chr}}{$bp} = 1;
			last;
		    }
		    if (($pos >= $bp) and ($pos <= $invend)){
			if ($end <= $invend){
			    if ($len >= $invlen * $min_overlap_ratio2){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($invend - $pos >= $invlen * $min_overlap_ratio2) and ($invend - $pos >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		    elsif (($bp >= $pos) and ($bp <= $end)){
			if ($invend <= $end){
			    if ($invlen >= $len * $min_overlap_ratio){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
			else{
			    if (($end - $bp >= $invlen * $min_overlap_ratio2) and ($end - $bp >= $len * $min_overlap_ratio2)){
				$flag = 1;
				${${$match_ref{$type}}{$chr}}{$bp} = 1;
				last;
			    }
			}
		    }
		}
	    }
	    if ($flag == 1){
		$match_del_num ++ if ($type eq 'DEL');
		$match_dup_num ++ if ($type eq 'DUP');
		$match_ins_num ++ if ($type eq 'INS');
		$match_inv_num ++ if ($type eq 'INV');
		if ($type eq 'DEL'){
		    if ($sv_size eq 'SS'){
			if ($hit_len > 100){
			    $recal_del_num ++;
			}
		    }
		    elsif ($sv_size eq 'S'){
			if (($hit_len <= 100) or ($hit_len > 1000)){
			    $recal_del_num ++;
			}
		    }
		    elsif ($sv_size eq 'M'){
			if (($hit_len <= 1000) or ($hit_len > 100000)){
			    $recal_del_num ++;
			}
		    }
		    elsif ($sv_size eq 'L'){
			if ($hit_len <= 100000){
			    $recal_del_num ++;
			}
		    }
		}
		elsif ($type eq 'DUP'){
		    if ($sv_size eq 'S'){
			if ($hit_len > 1000){
			    $recal_dup_num ++;
			}
		    }
		    elsif ($sv_size eq 'M'){
			if (($hit_len <= 1000) or ($hit_len > 100000)){
			    $recal_dup_num ++;
			}
		    }
		    elsif ($sv_size eq 'L'){
			if ($hit_len <= 100000){
			    $recal_dup_num ++;
			}
		    }
		}
		$pre_info{$type} = "$chr=$pos=$len=1";
#print "${$vcf{$chr}}{$pos}\n";
	    }
	    elsif ($flag == 2){
		$uncall_dup_num ++ if ($type eq 'DUP');
		$uncall_ins_num ++ if ($type eq 'INS');
	    }
	    else{
		$pre_info{$type} = "$chr=$pos=$len=0";
	    }
            if (($flag >= 1) and ($output_vcf == 1) and ($set2 =~ /=/)){
                print OUT2 "${$vcf{$chr}}{$pos}\n";
            }
	}
    }
    
    $sv_size = 'A' if ($sv_size eq 'ALL');
    if ($call_del_num > 0){
	my $recall = 0;
	my $precis = 0;
	$recall = int (($match_del_num - $recal_del_num) / $ref_del_num * 1000) / 10;
	$precis = int ($match_del_num / $call_del_num * 1000) / 10;
	if ($recall == 0){
	    $recall = int (($match_del_num - $recal_del_num)/ $ref_del_num * 10000) / 100;
	}
	if ($precis == 0){
	    $precis = int ($match_del_num / $call_del_num * 10000) / 100;
	}
	if ($eval_out eq ''){
	    print "DEL ($sv_size)\t$recall\t$precis\t$call_del_num\n";
	}
	else{
	    print OUT "DEL ($sv_size)\t$recall\t$precis\t$call_del_num\n";
	}
    }
    if ($call_dup_num > 0){
	my $recall = 0;
	my $precis = 0;
	$recall = int (($match_dup_num - $recal_dup_num)/ $ref_dup_num * 1000) / 10;
	$precis = int ($match_dup_num / ($call_dup_num - $uncall_dup_num) * 1000) / 10 if ($call_dup_num - $uncall_dup_num > 0);
	if ($recall == 0){
	    $recall = int (($match_dup_num - $recal_dup_num)/ $ref_dup_num * 10000) / 100;
	}
	if ($precis == 0){
	    $precis = int ($match_dup_num / ($call_dup_num - $uncall_dup_num) * 10000) / 100 if ($call_dup_num - $uncall_dup_num > 0);
	}
	if ($eval_out eq ''){
	    print "DUP ($sv_size)\t$recall=$precis\t$call_dup_num\n";
	}
	else{
	    print OUT "DUP ($sv_size)\t$recall\t$precis\t$call_dup_num\n";
	}
    }
    if ($call_ins_num > 0){
	my $recall = 0;
	my $precis = 0;
	$recall = int ($match_ins_num / $ref_ins_num * 1000) / 10;
	$precis = int ($match_ins_num / ($call_ins_num - $uncall_ins_num) * 1000) / 10 if ($call_ins_num - $uncall_ins_num > 0);
	if ($recall == 0){
	    $recall = int ($match_ins_num / $ref_ins_num * 10000) / 100;
	}
	if ($precis == 0){
	    $precis = int ($match_ins_num / ($call_ins_num - $uncall_ins_num) * 10000) / 100 if ($call_ins_num - $uncall_ins_num > 0);
	}
	if ($eval_out eq ''){
	    print "INS ($sv_size)\t$recall\t$precis\t$call_ins_num\n";
	}
	else{
	    print OUT "INS ($sv_size)\t$recall\t$precis\t$call_ins_num\n";
	}
    }
    if ($call_inv_num > 0){
	my $recall = 0;
	my $precis = 0;
	$recall = int ($match_inv_num / $ref_inv_num * 1000) / 10;
	$precis = int ($match_inv_num / $call_inv_num * 1000) / 10;
	if ($recall == 0){
	    $recall = int ($match_inv_num / $ref_inv_num * 10000) / 100;
	}
	if ($precis == 0){
	    $precis = int ($match_inv_num / $call_inv_num * 10000) / 100;
	}
	if ($eval_out eq ''){
	    print "INV ($sv_size)\t$recall\t$precis\t$call_inv_num\n";
	}
	else{
	    print OUT "INV ($sv_size)\t$recall\t$precis\t$call_inv_num\n";
	}
    }
    close (OUT2) if ($output_vcf == 1) and ($set2 =~ /=/);
}
close (OUT) if ($eval_out ne '');
print "\n";

sub merge_sv2{
    my ($type, $pair1, $pair2) = @_;
    my %vcf_or;
    my %vcf_or_info;
    my $call_or = 0;
    my $match_or = 0;
    my $overlap_match = 0;
    my $match_dupins_or = 0;
    my $add_ref = 0;
    my $overlap_id = '';
    my @ids;
    my ($id1, $id2) = ('', '');
    my ($id3, $id4) = ('', '');
    ($id1, $id2) = split (/=/, $pair1) if ($pair1 =~ /=/);
    $id1 = $pair1 if ($pair1 !~ /=/);
    ($id3, $id4) = split (/=/, $pair2) if ($pair2 =~ /=/);
    $id3 = $pair2 if ($pair2 !~ /=/);
    my $id1_base = lc $1 if ($id1 =~ /(.+):\d+$/);
    my $id2_base = lc $1 if ($id2 =~ /(.+):\d+$/) and ($id2 ne '');
    my $id3_base = lc $1 if ($id3 =~ /(.+):\d+$/);
    my $id4_base = lc $1 if ($id4 =~ /(.+):\d+$/) and ($id4 ne '');
    push @ids, $id1_base;
    push @ids, $id2_base if ($id2 ne '');
    push @ids, $id3_base;
    push @ids, $id4_base if ($id4 ne '');
    my $SD_id1S = 10000;
    my $SD_id1M = 10000;
    my $SD_id1L = 10000;
    my $SD_id2S = 10000;
    my $SD_id2M = 10000;
    my $SD_id2L = 10000;
    my $SD_id3S = 10000;
    my $SD_id3M = 10000;
    my $SD_id3L = 10000;
    my $SD_id4S = 10000;
    my $SD_id4M = 10000;
    my $SD_id4L = 10000;
    if ($type ne 'INS'){
	$SD_id1S = ${${$SDlen{$type}}{'S'}}{$id1_base} if (exists ${${$SDlen{$type}}{'S'}}{$id1_base});
	$SD_id1M = ${${$SDlen{$type}}{'M'}}{$id1_base} if (exists ${${$SDlen{$type}}{'M'}}{$id1_base});
	$SD_id1L = ${${$SDlen{$type}}{'L'}}{$id1_base} if (exists ${${$SDlen{$type}}{'L'}}{$id1_base});
	$SD_id3S = ${${$SDlen{$type}}{'S'}}{$id3_base} if (exists ${${$SDlen{$type}}{'S'}}{$id3_base});
	$SD_id3M = ${${$SDlen{$type}}{'M'}}{$id3_base} if (exists ${${$SDlen{$type}}{'M'}}{$id3_base});
	$SD_id3L = ${${$SDlen{$type}}{'L'}}{$id3_base} if (exists ${${$SDlen{$type}}{'L'}}{$id3_base});
	if ($id2 ne ''){
	    $SD_id2S = ${${$SDlen{$type}}{'S'}}{$id2_base} if (exists ${${$SDlen{$type}}{'S'}}{$id2_base});
	    $SD_id2M = ${${$SDlen{$type}}{'M'}}{$id2_base} if (exists ${${$SDlen{$type}}{'M'}}{$id2_base});
	    $SD_id2L = ${${$SDlen{$type}}{'L'}}{$id2_base} if (exists ${${$SDlen{$type}}{'L'}}{$id2_base});
	}
	if ($id4 ne ''){
	    $SD_id4S = ${${$SDlen{$type}}{'S'}}{$id4_base} if (exists ${${$SDlen{$type}}{'S'}}{$id4_base});
	    $SD_id4M = ${${$SDlen{$type}}{'M'}}{$id4_base} if (exists ${${$SDlen{$type}}{'M'}}{$id4_base});
	    $SD_id4L = ${${$SDlen{$type}}{'L'}}{$id4_base} if (exists ${${$SDlen{$type}}{'L'}}{$id4_base});
	}
    }
    if (($id2 ne '') and ($id4 ne '')){
	my $id3_base = $1 if ($id3 =~ /(.+):\d+/);
	my $id4_base = $1 if ($id4 =~ /(.+):\d+/);
	if ($pair1 =~ /$id3_base:/){
	    $overlap_id = $id3;
	}
	elsif ($pair1 =~ /$id4_base:/){
	    $overlap_id = $id4;
	}
    }
    elsif (($id2 ne '') and ($id4 eq '')){
	$overlap_id = $id4;
    }
    else{
	$overlap_id = 'both';
    }
    
    foreach my $chr (keys %{${$sv_and{$type}}{$pair1}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair1}}{$chr}}){
	    my ($pos12, $len12) = split (/\|/, ${${${$sv_and{$type}}{$pair1}}{$chr}}{$pos});
	    my ($len1, $len2) = split (/=/, $len12);
	    my $len = 0;
	    if ($type ne 'INS'){
		if ($len12 !~ /=/){
		    $len = $len12;
		}
		else{
		    my $SD1 = 0;
		    my $SD2 = 0;
		    $SD1 = $SD_id1S if ($len1 < 1000);
		    $SD1 = $SD_id1M if ($len1 >= 1000);
		    $SD1 = $SD_id1L if ($len1 >= 100000);
		    $SD2 = $SD_id2S if ($len2 < 1000);
		    $SD2 = $SD_id2M if ($len2 >= 1000);
		    $SD2 = $SD_id2L if ($len2 >= 100000);
		    if ((($SD1 <= 5) and ($SD2 <= 5)) or (abs ($SD1 - $SD2) < $SD1 * 0.5) or (abs ($SD1 - $SD2) < $SD2 * 0.5)){
			$len = int (($len1 + $len2) / 2 + 0.5);
		    }
		    else{
			$len = $len1 if ($SD1 <= $SD2);
			$len = $len2 if ($SD1 > $SD2);
		    }
		}
	    }
	    ${$vcf_or{$chr}}{$pos} = $len;
	    ${$vcf_or_info{$chr}}{$pos} = "$pair1|$pos12|$len12";
	}
    }
    foreach my $chr (keys %{${$sv_and{$type}}{$pair2}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair2}}{$chr}}){
	    my ($pos34, $len34) = split (/\|/, ${${${$sv_and{$type}}{$pair2}}{$chr}}{$pos});
	    my @pos34 = split (/=/, $pos34);
	    if (exists ${$vcf_or{$chr}}{$pos}){
		my $len = 0;
		my ($pair12, $pos12, $len12) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		if ($type ne 'INS'){
		    my ($len1, $len2) = split (/=/, $len12);
		    my ($len3, $len4) = split (/=/, $len34);
		    my $top_id = '';
		    my $sec_id = '';
		    my @topSD;
		    my %SD;
		    my %LEN;
		    $SD{$id1_base} = $SD_id1S if ($len1 < 1000);
		    $SD{$id1_base} = $SD_id1M if ($len1 >= 1000);
		    $SD{$id1_base} = $SD_id1L if ($len1 >= 100000);
		    $SD{$id2_base} = $SD_id2S if ($id2 ne '') and ($len2 < 1000);
		    $SD{$id2_base} = $SD_id2M if ($id2 ne '') and ($len2 >= 1000);
		    $SD{$id2_base} = $SD_id2L if ($id2 ne '') and ($len2 >= 100000);
		    $SD{$id3_base} = $SD_id3S if ($len3 < 1000);
		    $SD{$id3_base} = $SD_id3M if ($len3 >= 1000);
		    $SD{$id3_base} = $SD_id3L if ($len3 >= 100000);
		    $SD{$id4_base} = $SD_id4S if ($id4 ne '') and ($len4 < 1000);
		    $SD{$id4_base} = $SD_id4M if ($id4 ne '') and ($len4 >= 1000);
		    $SD{$id4_base} = $SD_id4L if ($id4 ne '') and ($len4 >= 100000);
		    $LEN{$id1_base} = $len1;
		    $LEN{$id2_base} = $len2 if ($id2 ne '');
		    $LEN{$id3_base} = $len3;
		    $LEN{$id4_base} = $len4 if ($id4 ne '');
		    my $count = 0;
		    foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			$count ++;
			$top_id = $id if ($count == 1);
			$sec_id = $id if ($count == 2);
			push @topSD, $id if ($SD{$id} <= 50);
		    }
		    if (@topSD >= 3){
			my $sum_len = 0;
			map{$sum_len += $LEN{$_}} @topSD;
			$len = int ($sum_len / @topSD + 0.5);
		    }
		    elsif ((($SD{$top_id} <= 50) and ($SD{$sec_id} <= 50)) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			$len = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
		    }
		    else{
			$len = $LEN{$top_id};
		    }
		}
		${$vcf_or{$chr}}{$pos} = $len;
		${$vcf_or_info{$chr}}{$pos} = "$pair12=$pair2|$pos12=$pos34|$len12=$len34";
	    }
	    else{
		my $len = 0;
		if ($type ne 'INS'){
		    if ($len34 !~ /=/){
			$len = $len34;
		    }
		    else{
			my ($len3, $len4) = split (/=/, $len34);
			my $SD3 = 0;
			my $SD4 = 0;
			$SD3 = $SD_id3S if ($len3 < 1000);
			$SD3 = $SD_id3M if ($len3 >= 1000);
			$SD3 = $SD_id3L if ($len3 >= 100000);
			$SD4 = $SD_id4S if ($len4 < 1000);
			$SD4 = $SD_id4M if ($len4 >= 1000);
			$SD4 = $SD_id4L if ($len4 >= 100000);
			if ((($SD3 <= 50) and ($SD4 <= 50)) or (abs ($SD3 - $SD4) < $SD3 * 0.5) or (abs ($SD3 - $SD4) < $SD4 * 0.5)){
			    $len = int (($len3 + $len4) / 2 + 0.5);
			}
			else{
			    $len = $len3 if ($SD3 <= $SD4);
			    $len = $len4 if ($SD3 > $SD4);
			}
		    }
		}
		${$vcf_or{$chr}}{$pos} = $len;
		${$vcf_or_info{$chr}}{$pos} = "$pair2|$pos34|$len34";
	    }
	}
    }
    foreach my $chr (keys %vcf_or){
	my $pre_pos = 0;
	my $pre_end = 0;
	my $pre_len = 0;
	foreach my $pos (sort {$a <=> $b} keys %{$vcf_or{$chr}}){
	    next if (!exists ${$vcf_or{$chr}}{$pos});
	    my $len = ${$vcf_or{$chr}}{$pos};
	    my $end = $pos + $len - 1;
	    my $overlap_flag = 0;
	    if ($pre_pos > 0){
		if ($type eq 'INS'){
		    if (abs ($pos - $pre_pos) <= $var_sd){
			$overlap_flag = 1;
		    }
		}
		else{
		    if ((abs ($pos - $pre_pos) <= $var_sd) and (abs ($end - $pre_end) <= $var_sd)){
			$overlap_flag = 2;
		    }
		    if (($pos >= $pre_pos) and ($end <= $pre_end)){
			$overlap_flag = 2;
		    }
		    if ($pos < $pre_end){
			if (($pre_end - $pos >= $pre_len * $min_overlap_ratio) and ($pre_end - $pos >= $len * $min_overlap_ratio)){
			    if ($pre_len >= $len){
				$overlap_flag = 2;
			    }
			    else{
				$overlap_flag = 3;
			    }
			}
			elsif ($pre_end - $pos >= $pre_len * $min_overlap_ratio){
			    if ((($len >= $pre_len) and ($len < $pre_len * 5)) or (($len < $pre_len) and ($pre_len < $len * 5))){
				$overlap_flag = 3;
			    }
			}
			elsif ($pre_end - $pos >= $len * $min_overlap_ratio){
			    if ((($len >= $pre_len) and ($len < $pre_len * 5)) or (($len < $pre_len) and ($pre_len < $len * 5))){
				$overlap_flag = 2;
			    }
			}
		    }
		}
	    }
	    if ($overlap_flag > 0){
		my ($pre_pair, $pre_pos2, $pre_len2) = split (/\|/, ${$vcf_or_info{$chr}}{$pre_pos});
		my ($cur_pair, $cur_pos, $cur_len) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		my @pre_pair = split (/=/, $pre_pair);
		my @cur_pair = split (/=/, $cur_pair);
		if (@pre_pair > @cur_pair){
		    delete ${$vcf_or{$chr}}{$pos};
		    next;
		}
		elsif (@pre_pair < @cur_pair){
		    delete ${$vcf_or{$chr}}{$pre_pos};
		}
		elsif ($pre_pair eq $cur_pair){
		    if ($overlap_flag <= 2){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    elsif ($overlap_flag == 3){
			delete ${$vcf_or{$chr}}{$pre_pos};
		    }
		}
		else{
		    my @pre_pos = split (/=/, $pre_pos2);
		    my @pre_len = split (/=/, $pre_len2);
		    my @cur_pos = split (/=/, $cur_pos);
		    my @cur_len = split (/=/, $cur_len);
		    my $pos_2 = 0;
		    my $len_2 = 0;		    
		    my $top_id2 = '';
		    my $sec_id2 = '';
		    my %SD2;
		    my %BP;
		    my @topSD2;
		    my $count2 = 0;
		    foreach my $id (@pre_pair){
			my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			my $length = $pre_len[$count2];
			my $posit = $pre_pos[$count2];
			$BP{$id_base} = $posit;
			$SD2{$id_base} = ${${$SDbp{$type}}{'S'}}{$id_base} if ($length < 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'M'}}{$id_base} if ($length >= 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'L'}}{$id_base} if ($length >= 100000);
                        if (!exists $SD2{$id_base}){
                            $SD2{$id_base} = 100;
                        }
			$count2 ++;
		    }
		    $count2 = 0;
		    foreach my $id (@cur_pair){
			my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			my $length = $cur_len[$count2];
			my $posit = $pre_pos[$count2];
			$BP{$id_base} = $posit;
			$SD2{$id_base} = ${${$SDbp{$type}}{'S'}}{$id_base} if ($length < 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'M'}}{$id_base} if ($length >= 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'L'}}{$id_base} if ($length >= 100000);
                        if (!exists $SD2{$id_base}){
                            $SD2{$id_base} = 100;
                        }
			$count2 ++;
		    }
                    
		    $count2 = 0;
		    foreach my $id (sort {$SD2{$a} <=> $SD2{$b}} keys %SD2){
			$count2 ++;
			$top_id2 = $id if ($count2 == 1);
			$sec_id2 = $id if ($count2 == 2);
			push @topSD2, $id if ($SD2{$id} <= 10);
		    }
		    if (@topSD2 >= 3){
			my $sum_pos = 0;
			map{$sum_pos += $BP{$_}} @topSD2;
			$pos_2 = int ($sum_pos / @topSD2 + 0.5);
		    }
		    elsif ((($SD2{$top_id2} <= 5) and ($SD2{$sec_id2} <= 5)) or (abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$top_id2} * 0.5) or (abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$sec_id2} * 0.5)){
			$pos_2 = int (($BP{$top_id2} + $BP{$sec_id2}) / 2 + 0.5);
		    }
		    else{
			$pos_2 = $BP{$top_id2};
		    }
		    
		    if ($type ne 'INS'){
			my $top_id = '';
			my $sec_id = '';
			my %SD;
			my %LEN;
			my @topSD;
			my $count = 0;
			foreach my $id (@pre_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $length = $pre_len[$count];
			    $LEN{$id_base} = $length;
			    $SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}
			$count = 0;
			foreach my $id (@cur_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $length = $cur_len[$count];
			    $LEN{$id_base} = $length;
			    $SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}		    
			$count = 0;
			foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			    $count ++;
			    $top_id = $id if ($count == 1);
			    $sec_id = $id if ($count == 2);
			    push @topSD, $id if ($SD{$id} <= 50);
			}
			if (@topSD >= 3){
			    my $sum_len = 0;
			    map{$sum_len += $LEN{$_}} @topSD;
			    $len_2 = int ($sum_len / @topSD + 0.5);
			}
			elsif ((($SD{$top_id} <= 50) and ($SD{$sec_id} <= 50)) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			    $len_2 = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
			}
			else{
			    $len_2 = $LEN{$top_id};
			}
		    }
#print STDERR "$pair1\t$pair2\t$chr\t$pos\n" if ($len_2 == 0);
		    delete ${$vcf_or_info{$chr}}{$pos};
		    delete ${$vcf_or_info{$chr}}{$pre_pos};
		    ${$vcf_or_info{$chr}}{$pos_2} = "$pre_pair=$cur_pair|$pre_pos2=$cur_pos|$pre_len2=$cur_len";
		    delete ${$vcf_or{$chr}}{$pos};
		    delete ${$vcf_or{$chr}}{$pre_pos};
		    ${$vcf_or{$chr}}{$pos_2} = $len_2;
		    my $end_2 = $pos_2 + $len_2 - 1;
		    $pre_pos = $pos_2;
		    $pre_end = $end_2;
		    $pre_len = $len_2;
		    next;
		}
	    }
	    $pre_pos = $pos;
	    $pre_end = $end;
	    $pre_len = $len;
	}
    }

    foreach my $chr (keys %vcf_or){
	foreach my $pos (keys %{$vcf_or{$chr}}){
	    my ($pair_g, $pos_g, $len_g) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
	    my $pair_pair1 = "$pair1~$pair2";
	    ${${${$sv_and_or{$type}}{$pair_pair1}}{$chr}}{$pos} = "$pair_g|$pos_g|$len_g|${$vcf_or{$chr}}{$pos}";
	}
    }
}

sub merge_tra2{
    my ($type, $pair1, $pair2) = @_;
    my %vcf_or;
    my %vcf_or_info;
    my $call_or = 0;
    my $match_or = 0;
    my $overlap_id = '';
    my @ids;
    my ($id1, $id2) = ('', '');
    my ($id3, $id4) = ('', '');
    ($id1, $id2) = split (/=/, $pair1) if ($pair1 =~ /=/);
    $id1 = $pair1 if ($pair1 !~ /=/);
    ($id3, $id4) = split (/=/, $pair2) if ($pair2 =~ /=/);
    $id3 = $pair2 if ($pair2 !~ /=/);
    my $id1_base = lc $1 if ($id1 =~ /(.+):\d+$/);
    my $id2_base = lc $1 if ($id2 =~ /(.+):\d+$/) and ($id2 ne '');
    my $id3_base = lc $1 if ($id3 =~ /(.+):\d+$/);
    my $id4_base = lc $1 if ($id4 =~ /(.+):\d+$/) and ($id4 ne '');
    push @ids, $id1_base;
    push @ids, $id2_base if ($id2 ne '');
    push @ids, $id3_base;
    push @ids, $id4_base if ($id4 ne '');
    my $SD_id1 = 10000;
    my $SD_id2 = 10000;
    my $SD_id3 = 10000;
    my $SD_id4 = 10000;
    if ($type ne 'INS'){
	$SD_id1 = ${${$SDlen{$type}}{'T'}}{$id1_base} if (exists ${${$SDlen{$type}}{'T'}}{$id1_base});
	$SD_id3 = ${${$SDlen{$type}}{'T'}}{$id3_base} if (exists ${${$SDlen{$type}}{'T'}}{$id3_base});
	if ($id2 ne ''){
	    $SD_id2 = ${${$SDlen{$type}}{'T'}}{$id2_base} if (exists ${${$SDlen{$type}}{'T'}}{$id2_base});
	}
	if ($id4 ne ''){
	    $SD_id4 = ${${$SDlen{$type}}{'T'}}{$id4_base} if (exists ${${$SDlen{$type}}{'T'}}{$id4_base});
	}
    }
    if (($id2 ne '') and ($id4 ne '')){
	my $id3_base = $1 if ($id3 =~ /(.+):\d+/);
	my $id4_base = $1 if ($id4 =~ /(.+):\d+/);
	if ($pair1 =~ /$id3_base:/){
	    $overlap_id = $id3;
	}
	elsif ($pair1 =~ /$id4_base:/){
	    $overlap_id = $id4;
	}
    }
    elsif (($id2 ne '') and ($id4 eq '')){
	$overlap_id = $id4;
    }
    else{
	$overlap_id = 'both';
    }
    
    foreach my $chr (keys %{${$sv_and{$type}}{$pair1}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair1}}{$chr}}){
	    my ($chr2, $pos12, $pos_tra12) = split (/\|/, ${${${$sv_and{$type}}{$pair1}}{$chr}}{$pos});
	    my @pos_tra12 = split (/=/, $pos_tra12);
	    my $pos_tra = 0;
	    if ($pos_tra12 !~ /=/){
		$pos_tra = $pos_tra12;
	    }
	    else{
		my ($pos_tra1, $pos_tra2) = split (/=/, $pos_tra12);
		if ((($SD_id1 <= 50) and ($SD_id2 <= 50)) or (abs ($SD_id1 - $SD_id2) < $SD_id1 * 0.5) or (abs ($SD_id1 - $SD_id2) < $SD_id2 * 0.5)){
		    $pos_tra = int (($pos_tra1 + $pos_tra2) / 2 + 0.5);
		}
		else{
		    $pos_tra = $pos_tra1 if ($SD_id1 <= $SD_id2);
		    $pos_tra = $pos_tra2 if ($SD_id1 > $SD_id2);
		}
	    }
	    ${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
	    ${$vcf_or_info{$chr}}{$pos} = "$pair1|$chr2|$pos12|$pos_tra12";
	}
    }
    foreach my $chr (keys %{${$sv_and{$type}}{$pair2}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair2}}{$chr}}){
	    my ($chr2, $pos34, $pos_tra34) = split (/\|/, ${${${$sv_and{$type}}{$pair2}}{$chr}}{$pos});
	    my @pos34 = split (/=/, $pos34);
	    my ($pos_tra3, $pos_tra4) = split (/=/, $pos_tra34);
	    my $pos_tra = 0;
	    if (exists ${$vcf_or{$chr}}{$pos}){
		my ($pair12, $chr2, $pos12, $pos_tra12) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		my ($pos_tra1, $pos_tra2) = split (/=/, $pos_tra12);
		my $top_id = '';
		my $sec_id = '';
		my %SD;
		my %LEN;
		my @topSD;
		$SD{$id1_base} = $SD_id1;
		$SD{$id2_base} = $SD_id2 if ($id2 ne '');
		$SD{$id3_base} = $SD_id3;
		$SD{$id4_base} = $SD_id4 if ($id4 ne '');
		$LEN{$id1_base} = $pos_tra1;
		$LEN{$id2_base} = $pos_tra2 if ($id2 ne '');
		$LEN{$id3_base} = $pos_tra3;
		$LEN{$id4_base} = $pos_tra4 if ($id4 ne '');
		my $count = 0;
		foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
		    $count ++;
		    $top_id = $id if ($count == 1);
		    $sec_id = $id if ($count == 2);
		    push @topSD, $id if ($SD{$id} <= 50);
		}
		if (@topSD >= 3){
		    my $sum_len = 0;
		    map{$sum_len += $LEN{$_}} @topSD;
		    $pos_tra = int ($sum_len / @topSD + 0.5);
		}
		elsif ((($SD{$top_id} <= 50) and ($SD{$sec_id} <= 50)) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
		    $pos_tra = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
		}
		else{
		    $pos_tra = $LEN{$top_id};
		}
		${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
		${$vcf_or_info{$chr}}{$pos} = "$pair12=$pair2|$chr2|$pos12=$pos34|$pos_tra12=$pos_tra34";
	    }
	    else{
		if ($pos_tra34 !~ /=/){
		    $pos_tra = $pos_tra34;
		}
		else{
		    if ((($SD_id3 <= 50) and ($SD_id4 <= 50)) or (abs ($SD_id3 - $SD_id4) < $SD_id3 * 0.5) or (abs ($SD_id3 - $SD_id4) < $SD_id4 * 0.5)){
			$pos_tra = int (($pos_tra3 + $pos_tra4) / 2 + 0.5);
		    }
		    else{
			$pos_tra = $pos_tra3 if ($SD_id3 <= $SD_id4);
			$pos_tra = $pos_tra4 if ($SD_id3 > $SD_id4);
		    }
		}
		${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
		${$vcf_or_info{$chr}}{$pos} = "$pair2|$chr2|$pos34|$pos_tra34";
	    }
	}
    }

    foreach my $chr (keys %vcf_or){
	my $pre_pos = 0;
	foreach my $pos (sort {$a <=> $b} keys %{$vcf_or{$chr}}){
	    next if (!exists ${$vcf_or{$chr}}{$pos});
	    if ($pre_pos > 0){
		if ($pos - $pre_pos <= $ctx_sd){
		    my ($pre_pair, $pre_chr2, $pre_pos2, $pre_pos_tra) = split (/\|/, ${$vcf_or_info{$chr}}{$pre_pos});
		    my ($cur_pair, $cur_chr2, $cur_pos, $cur_pos_tra) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		    my @pre_pair = split (/=/, $pre_pair);
		    my @cur_pair = split (/=/, $cur_pair);
		    next if ($pre_chr2 ne $cur_chr2);
		    if ($pre_pair eq 'pair4'){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    elsif ($cur_pair eq 'pair4'){
			delete ${$vcf_or{$chr}}{$pre_pos};
		    }
		    elsif ($pre_pair eq $cur_pair){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    else{
			my @pre_pos = split (/=/, $pre_pos2);
			my @pre_pos_tra = split (/=/, $pre_pos_tra);
			my @cur_pos = split (/=/, $cur_pos);
			my @cur_pos_tra = split (/=/, $cur_pos_tra);
			my @all_pos = (@pre_pos, @cur_pos);
			my @all_pos_tra = (@pre_pos_tra, @cur_pos_tra);
			my $pos_2 = 0;
			my $pos_tra_2 = 0;
			my $top_id2 = '';
			my $sec_id2 = '';
			my %SD2;
			my %BP;
			my @topSD2;
			my $count2 = 0;
			foreach my $id (@pre_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $pos2 = $pre_pos[$count2];
			    $BP{$id_base} = $pos2;
			    $SD2{$id_base} = ${${$SDbp{$type}}{'T'}}{$id_base};
                            if (!exists $SD2{$id_base}){
                                $SD2{$id_base} = 100;
                            }
			    $count2 ++;
			}
			$count2 = 0;
			foreach my $id (@cur_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $pos2 = $cur_pos[$count2];
			    $BP{$id_base} = $pos2;
			    $SD2{$id_base} = ${${$SDbp{$type}}{'T'}}{$id_base};
                            if (!exists $SD2{$id_base}){
                                $SD2{$id_base} = 100;
                            }
			    $count2 ++;
			}
			$count2 = 0;
			foreach my $id (sort {$SD2{$a} <=> $SD2{$b}} keys %SD2){
			    $count2 ++;
			    $top_id2 = $id if ($count2 == 1);
			    $sec_id2 = $id if ($count2 == 2);
			    push @topSD2, $id if ($SD2{$id} <= 50);
			}
			if (@topSD2 >= 3){
			    my $sum_pos = 0;
			    map{$sum_pos += $BP{$_}} @topSD2;
			    $pos_2 = int ($sum_pos / @topSD2 + 0.5);
			}
			if ((($SD2{$top_id2} <= 50) and ($SD2{$sec_id2} <= 50)) or (abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$top_id2} * 0.5) or (abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$sec_id2} * 0.5)){
			    $pos_2 = int (($BP{$top_id2} + $BP{$sec_id2}) / 2 + 0.5);
			}
			else{
			    $pos_2 = $BP{$top_id2};
			}
			
			my $top_id = '';
			my $sec_id = '';
			my %SD;
			my %LEN;
			my @topSD;
			my $count = 0;
			foreach my $id (@pre_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $postra = $pre_pos_tra[$count];
			    $LEN{$id_base} = $postra;
			    $SD{$id_base} = ${${$SDlen{$type}}{'T'}}{$id_base};
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}
			$count = 0;
			foreach my $id (@cur_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $postra = $cur_pos_tra[$count];
			    $LEN{$id_base} = $postra;
			    $SD{$id_base} = ${${$SDlen{$type}}{'T'}}{$id_base};
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}
			$count = 0;
			foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			    $count ++;
			    $top_id = $id if ($count == 1);
			    $sec_id = $id if ($count == 2);
			    push @topSD, $id if ($SD{$id} <= 50);
			}
			if (@topSD >= 3){
			    my $sum_len = 0;
			    map{$sum_len += $LEN{$_}} @topSD;
			    $pos_tra_2 = int ($sum_len / @topSD + 0.5);
			}
			if ((($SD{$top_id} <= 50) and ($SD{$sec_id} <= 50)) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			    $pos_tra_2 = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
			}
			else{
			    $pos_tra_2 = $LEN{$top_id};
			}
			delete ${$vcf_or_info{$chr}}{$pos};
			delete ${$vcf_or_info{$chr}}{$pre_pos};
			${$vcf_or_info{$chr}}{$pos_2} = "$pre_pair=$cur_pair|$pre_chr2|$pre_pos2=$cur_pos|$pre_pos_tra=$cur_pos_tra";
			delete ${$vcf_or{$chr}}{$pos};
			delete ${$vcf_or{$chr}}{$pre_pos};
			${$vcf_or{$chr}}{$pos_2} = "$pre_chr2=$pos_tra_2";
			$pre_pos = $pos_2;
			next;
		    }
		}
	    }
	    $pre_pos = $pos;
	}
    }
    
    my $pair_pair1 = "$pair1~$pair2";
    foreach my $chr (keys %vcf_or){
	foreach my $pos (keys %{$vcf_or{$chr}}){
	    my ($pair_g, $chr2_g, $pos_g, $pos_tra_g) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
	    my ($chr2_c, $pos_tra_c) = split (/=/, ${$vcf_or{$chr}}{$pos});
	    ${${${$sv_and_or{$type}}{$pair_pair1}}{$chr}}{$pos} = "$pair_g|$chr2_g|$pos_g|$pos_tra_g|$pos_tra_c";
	}
    }
}

sub merge_sv3{
    my ($type, $pair1, $pair2) = @_;
    my %vcf_or;
    my %vcf_or_info;
    my $call_or = 0;
    my $match_or = 0;
    my $overlap_match = 0;
    my $match_dupins_or = 0;
    my $add_ref = 0;
    my ($id1, $id2, $id3, $id4) = ('', '', '', '');
    my ($id5, $id6) = ('', '');
    my $pair1_2 = $pair1;
    $pair1_2 =~ s/~/=/;
    ($id1, $id2, $id3, $id4) = split (/=/, $pair1_2) if ($pair1_2 =~ /=/);
    $id1 = $pair1 if ($pair1_2 !~ /=/);
    ($id5, $id6) = split (/=/, $pair2) if ($pair2 =~ /=/);
    $id5 = $pair2 if ($pair2 !~ /=/);
    
    foreach my $chr (keys %{${$sv_and_or{$type}}{$pair1}}){
	foreach my $pos (keys %{${${$sv_and_or{$type}}{$pair1}}{$chr}}){
	    my ($pair12, $pos12, $len12, $len_c) = split (/\|/, ${${${$sv_and_or{$type}}{$pair1}}{$chr}}{$pos});
	    ${$vcf_or{$chr}}{$pos} = $len_c;
	    ${$vcf_or_info{$chr}}{$pos} = "$pair12|$pos12|$len12";
	}
    }
    foreach my $chr (keys %{${$sv_and{$type}}{$pair2}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair2}}{$chr}}){
	    my ($pos56, $len56) = split (/\|/, ${${${$sv_and{$type}}{$pair2}}{$chr}}{$pos});
	    my @pos56 = split (/=/, $pos56);
	    my @len56 = split (/=/, $len56);
	    my $len = 0;
	    if (exists ${$vcf_or{$chr}}{$pos}){
		my ($pair12, $pos12, $len12) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		my @pair12 = split (/=/, $pair12);
		my @pair56 = split (/=/, $pair2);
		my @len12 = split (/=/, $len12);		
		if ($type ne 'INS'){		    
		    my $top_id = '';
		    my $sec_id = '';
		    my %SD;
		    my %LEN;
		    my @topSD;
		    my $count = 0;
		    foreach my $id (@pair12){
			my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			my $length = $len12[$count];
			$LEN{$id_base} = $length;
			$SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			$SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			$SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                        if (!exists $SD{$id_base}){
                            $SD{$id_base} = 1000;
                        }
			$count ++;
		    }
		    $count = 0;
		    foreach my $id (@pair56){
			my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			my $length = $len56[$count];
			$LEN{$id_base} = $length;
			$SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			$SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			$SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                        if (!exists $SD{$id_base}){
                            $SD{$id_base} = 1000;
                        }
			$count ++;
		    }
		    $count = 0;
		    foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			$count ++;
			$top_id = $id if ($count == 1);
			$sec_id = $id if ($count == 2);
			push @topSD, $id if ($SD{$id} <= 50);
		    }
		    if (@topSD >= 3){
			my $sum_len = 0;
			map{$sum_len += $LEN{$_}} @topSD;
			$len = int ($sum_len / @topSD + 0.5);
		    }
		    elsif ((abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			$len = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
		    }
		    else{
			$len = $LEN{$top_id};
		    }
		}
		${$vcf_or{$chr}}{$pos} = $len;
		${$vcf_or_info{$chr}}{$pos} = "$pair12=$pair2|$pos12=$pos56|$len12=$len56";
	    }
	    else{
		if ($type ne 'INS'){
		    if ($len56 !~ /=/){
			$len = $len56;
		    }
		    else{
			my @pair56 = split (/=/, $pair2);
			my $top_id = '';
			my $sec_id = '';
			my %SD;
			my %LEN;
			my @topSD;
			my $count = 0;
			foreach my $id (@pair56){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $length = $len56[$count];
			    $LEN{$id_base} = $length;
			    $SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}
			$count = 0;
			foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			    $count ++;
			    $top_id = $id if ($count == 1);
			    $sec_id = $id if ($count == 2);
			    push @topSD, $id if ($SD{$id} <= 50);
			}
			if (@topSD >= 3){
			    my $sum_len = 0;
			    map{$sum_len += $LEN{$_}} @topSD;
			    $len = int ($sum_len / @topSD + 0.5);
			}
			elsif ((abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			    $len = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
			}
			else{
			    $len = $LEN{$top_id};
			}
		    }
		}
		${$vcf_or{$chr}}{$pos} = $len;
		${$vcf_or_info{$chr}}{$pos} = "$pair2|$pos56|$len56";
	    }
	}
    }
    foreach my $chr (keys %vcf_or){
	my $pre_pos = 0;
	my $pre_end = 0;
	my $pre_len = 0;
	foreach my $pos (sort {$a <=> $b} keys %{$vcf_or{$chr}}){
	    next if (!exists ${$vcf_or{$chr}}{$pos});
	    my $len = ${$vcf_or{$chr}}{$pos};
	    my $end = $pos + $len - 1;
	    my $overlap_flag = 0;
	    if ($pre_pos > 0){
		if ($type eq 'INS'){
		    if (abs ($pos - $pre_pos) <= $var_sd){
			$overlap_flag = 1;
		    }
		}
		else{
		    if ((abs ($pos - $pre_pos) <= $var_sd) and (abs ($end - $pre_end) <= $var_sd)){
			$overlap_flag = 2;
		    }
		    if (($pos >= $pre_pos) and ($end <= $pre_end)){
			$overlap_flag = 2;
		    }
		    if ($pos < $pre_end){
			if (($pre_end - $pos >= $pre_len * $min_overlap_ratio) and ($pre_end - $pos >= $len * $min_overlap_ratio)){
			    if ($pre_len >= $len){
				$overlap_flag = 2;
			    }
			    else{
				$overlap_flag = 3;
			    }
			}
			elsif ($pre_end - $pos >= $pre_len * $min_overlap_ratio){
			    if ((($len >= $pre_len) and ($len < $pre_len * 5)) or (($len < $pre_len) and ($pre_len < $len * 5))){
				$overlap_flag = 3;
			    }
			}
			elsif ($pre_end - $pos >= $len * $min_overlap_ratio){
			    if ((($len >= $pre_len) and ($len < $pre_len * 5)) or (($len < $pre_len) and ($pre_len < $len * 5))){
				$overlap_flag = 2;
			    }
			}
		    }
		}
	    }
	    if ($overlap_flag > 0){
print STDERR "pre_pos info is missing\n" if (!exists ${$vcf_or_info{$chr}}{$pre_pos});
print STDERR "cur_pos info is missing\n" if (!exists ${$vcf_or_info{$chr}}{$pos});
		my ($pre_pair, $pre_pos2, $pre_len2) = split (/\|/, ${$vcf_or_info{$chr}}{$pre_pos});
		my ($cur_pair, $cur_pos, $cur_len) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
		my @pre_pair = split (/=/, $pre_pair);
		my @cur_pair = split (/=/, $cur_pair);
		if ($pre_pair eq 'pair6'){
		    delete ${$vcf_or{$chr}}{$pos};
		    next;
		}
		elsif ($cur_pair eq 'pair6'){
		    delete ${$vcf_or{$chr}}{$pre_pos};
		}
		elsif ($pre_pair eq $cur_pair){
		    if ($overlap_flag <= 2){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    elsif ($overlap_flag == 3){
			delete ${$vcf_or{$chr}}{$pre_pos};
		    }
		}
		else{
		    my @pre_pos = split (/=/, $pre_pos2);
		    my @pre_len = split (/=/, $pre_len2);
		    my @cur_pos = split (/=/, $cur_pos);
		    my @cur_len = split (/=/, $cur_len);
		    my @all_pos = (@pre_pos, @cur_pos);
		    my @all_len = (@pre_len, @cur_len);
		    my $pos_2 = 0;
		    my $len_2 = 0;
		    my $top_id2 = '';
		    my $sec_id2 = '';
		    my %SD2;
		    my %BP;
		    my @topSD2;
		    my $count2 = 0;
		    foreach my $id (@pre_pair){
			my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			my $length = $pre_len[$count2];
			my $bp2 = $pre_pos[$count2];
			$BP{$id_base} = $bp2;
			$SD2{$id_base} = ${${$SDbp{$type}}{'S'}}{$id_base} if ($length < 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'M'}}{$id_base} if ($length >= 1000);
			$SD2{$id_base} = ${${$SDbp{$type}}{'L'}}{$id_base} if ($length >= 100000);
                        if (!exists $SD2{$id_base}){
                            $SD2{$id_base} = 100;
                        }
			$count2 ++;
		    }
		    $count2 = 0;
		    foreach my $id (sort {$SD2{$a} <=> $SD2{$b}} keys %SD2){
			$count2 ++;
			$top_id2 = $id if ($count2 == 1);
			$sec_id2 = $id if ($count2 == 2);
			push @topSD2, $id if ($SD2{$id} <= 10);
		    }
		    if (@topSD2 >= 3){
			my $sum_pos = 0;
			map{$sum_pos += $BP{$_}} @topSD2;
			$pos_2 = int ($sum_pos / @topSD2 + 0.5);
		    }
		    elsif ((abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$top_id2} * 0.5) or (abs ($SD2{$top_id2} - $SD2{$sec_id2}) < $SD2{$sec_id2} * 0.5)){
			$pos_2 = int (($BP{$top_id2} + $BP{$sec_id2}) / 2 + 0.5);
		    }
		    else{
			$pos_2 = $BP{$top_id2};
		    }
		    
		    if ($type ne 'INS'){
			my $top_id = '';
			my $sec_id = '';
			my %SD;
			my %LEN;
			my @topSD;
			my $count = 0;
			foreach my $id (@pre_pair){
			    my $id_base = lc $1 if ($id =~ /(.+):\d+$/);
			    my $length = $pre_len[$count];
			    $LEN{$id_base} = $length;
			    $SD{$id_base} = ${${$SDlen{$type}}{'S'}}{$id_base} if ($length < 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'M'}}{$id_base} if ($length >= 1000);
			    $SD{$id_base} = ${${$SDlen{$type}}{'L'}}{$id_base} if ($length >= 100000);
                            if (!exists $SD{$id_base}){
                                $SD{$id_base} = 1000;
                            }
			    $count ++;
			}
			$count = 0;
			foreach my $id (sort {$SD{$a} <=> $SD{$b}} keys %SD){
			    $count ++;
			    $top_id = $id if ($count == 1);
			    $sec_id = $id if ($count == 2);
			    push @topSD, $id if ($SD{$id} <= 50);
			}
			if (@topSD >= 3){
			    my $sum_len = 0;
			    map{$sum_len += $LEN{$_}} @topSD;
			    $len_2 = int ($sum_len / @topSD + 0.5);
			}
			elsif ((abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$top_id} * 0.5) or (abs ($SD{$top_id} - $SD{$sec_id}) < $SD{$sec_id} * 0.5)){
			    $len_2 = int (($LEN{$top_id} + $LEN{$sec_id}) / 2 + 0.5);
			}
			else{
			    $len_2 = $LEN{$top_id};
			}
		    }
		    delete ${$vcf_or_info{$chr}}{$pos};
		    delete ${$vcf_or_info{$chr}}{$pre_pos};
		    ${$vcf_or_info{$chr}}{$pos_2} = "$pre_pair=$cur_pair|$pre_pos2=$cur_pos|$pre_len2=$cur_len";
		    delete ${$vcf_or{$chr}}{$pos};
		    delete ${$vcf_or{$chr}}{$pre_pos};
		    ${$vcf_or{$chr}}{$pos_2} = $len_2;
		    my $end_2 = $pos_2 + $len_2 - 1;
		    $pre_pos = $pos_2;
		    $pre_end = $end_2;
		    $pre_len = $len_2;
		    next;
		}
	    }
	    $pre_pos = $pos;
	    $pre_end = $end;
	    $pre_len = $len;
	}
    }
    my $pair_pair1 = "$pair1~$pair2";
    foreach my $chr (keys %vcf_or){
	foreach my $pos (keys %{$vcf_or{$chr}}){
	    my ($pair_g, $pos_g, $len_g) = split (/\|/, ${$vcf_or_info{$chr}}{$pos});
	    ${${${$sv_and_or_or{$type}}{$pair_pair1}}{$chr}}{$pos} = "$pair_g|$pos_g|$len_g|${$vcf_or{$chr}}{$pos}";
	}
    }
}
=pod
sub merge_tra3{
    my ($type, $pair1, $pair2) = @_;
    my %vcf_or;
    my %vcf_or_info;
    my $call_or = 0;
    my $match_or = 0;
    my ($id1, $id2, $id3, $id4) = ('', '', '', '');
    my ($id5, $id6) = ('', '');
    my $pair1_2 = $pair1;
    $pair1_2 =~ s/\|/=/;
    ($id1, $id2, $id3, $id4) = split (/=/, $pair1_2) if ($pair1_2 =~ /=/);
    $id1 = $pair1 if ($pair1_2 !~ /=/);
    ($id5, $id6) = split (/=/, $pair2) if ($pair2 =~ /=/);
    $id5 = $pair2 if ($pair2 !~ /=/);
    my $id5_base = $1 if ($id5 =~ /(.+):\d+/);
    my $id6_base = $1 if ($id6 =~ /(.+):\d+/);
    my $overlap_id = '';
    if ($pair1 =~ /$id5_base:/){
	$overlap_id = $id5;
    }
    elsif (($id6 ne '') and ($pair1 =~ /$id6_base:/)){
	$overlap_id = $id6;
    }
    
    foreach my $chr (keys %{${$sv_and_or{$type}}{$pair1}}){
	foreach my $pos (keys %{${${$sv_and_or{$type}}{$pair1}}{$chr}}){
	    my ($chr2, $pos12, $pos_tra12, $pos_tra) = split (/\|/, ${${${$sv_and_or{$type}}{$pair1}}{$chr}}{$pos});
	    ${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
	    ${$vcf_or_info{$chr}}{$pos} = "$pair1||$chr2||$pos12||$pos_tra12";
	}
    }
    foreach my $chr (keys %{${$sv_and{$type}}{$pair2}}){
	foreach my $pos (keys %{${${$sv_and{$type}}{$pair2}}{$chr}}){
	    my ($chr2, $pos56, $pos_tra56) = split (/\|/, ${${${$sv_and{$type}}{$pair2}}{$chr}}{$pos});
	    my @pos56 = split (/=/, $pos56);
	    my @pos_tra56 = split (/=/, $pos_tra56);
	    my $pos_tra = 0;
	    if (exists ${$vcf_or{$chr}}{$pos}){
		my $sum_pos_tra = 0;
		my $pos_str = '';
		my $pos_tra_str = '';
		my $count_sum = 0;
		my $count_pos = 0;
		my %used_pos;
		my ($pair12, $chr2, $pos12, $pos_tra12) = split (/\|\|/, ${$vcf_or_info{$chr}}{$pos});
		my @pos12 = split (/=/, $pos12);
		my @pos_tra12 = split (/=/, $pos_tra12);
		my @all_pos = (@pos12, @pos56);
		my @all_pos_tra = (@pos_tra12, @pos_tra56);
		foreach my $pp (@all_pos){
		    $count_pos ++;
		    if (($overlap_id eq $id3) and (!exists $used_pos{$pp}) and (exists ${${${$call{$id3}}{$type}}{$chr}}{$pp})){
			$used_pos{$pp} = 1;
			next;
		    }
		    elsif (($overlap_id eq $id4) and (!exists $used_pos{$pp}) and (exists ${${${$call{$id4}}{$type}}{$chr}}{$pp})){
			$used_pos{$pp} = 1;
			next;
		    }
		    $pos_str .= "$pp=";
		    $pos_tra_str .= "$all_pos_tra[$count_pos - 1]=";
		    $sum_pos_tra += $all_pos_tra[$count_pos - 1];
		    $count_sum ++;
		}
		$pos_str =~ s/=$//;
		$pos_tra_str =~ s/=$//;
		$pos_tra = int ($sum_pos_tra / $count_sum);
		${$vcf_or_info{$chr}}{$pos} = "pair6||$chr2||$pos_str||$pos_tra_str";
		${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
	    }
	    else{
		if (@pos_tra56 == 1){
		    $pos_tra = $pos_tra56[0];
		}
		else{
		    $pos_tra = $pos_tra56[$domi_id2];
		}
		${$vcf_or{$chr}}{$pos} = "$chr2=$pos_tra";
		${$vcf_or_info{$chr}}{$pos} = "$pair2||$chr2||$pos56||$pos_tra56";
	    }
	}
    }

    foreach my $chr (keys %vcf_or){
	my $pre_pos = 0;
	foreach my $pos (sort {$a <=> $b} keys %{$vcf_or{$chr}}){
	    if ($pre_pos > 0){
		if ($pos - $pre_pos <= $ctx_sd){
		    my ($pre_pair, $pre_chr2, $pre_pos2, $pre_pos_tra) = split (/\|\|/, ${$vcf_or_info{$chr}}{$pre_pos});
		    my ($cur_pair, $cur_chr2, $cur_pos, $cur_pos_tra) = split (/\|\|/, ${$vcf_or_info{$chr}}{$pos});
		    next if ($pre_chr2 ne $cur_chr2);
		    if ($pre_pair eq 'pair6'){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    elsif ($cur_pair eq 'pair6'){
			delete ${$vcf_or{$chr}}{$pre_pos};
		    }
		    elsif ($pre_pair eq $cur_pair){
			delete ${$vcf_or{$chr}}{$pos};
			next;
		    }
		    else{
			my @pre_pos = split (/=/, $pre_pos2);
			my @pre_pos_tra = split (/=/, $pre_pos_tra);
			my @cur_pos = split (/=/, $cur_pos);
			my @cur_pos_tra = split (/=/, $cur_pos_tra);
			my @all_pos = (@pre_pos, @cur_pos);
			my @all_pos_tra = (@pre_pos_tra, @cur_pos_tra);
			my $pos_2 = 0;
			my $pos_tra_2 = 0;
			my $sum_pos = 0;
			my $sum_pos_tra = 0;
			my $pos_str = '';
			my $pos_tra_str = '';
			my $count_pos = 0;
			my $count_sum = 0;
			my %used_pos;
			foreach my $pp (@all_pos){
			    $count_pos ++;
			    if (($overlap_id eq $id6) and (!exists $used_pos{$pp}) and (exists ${${${$call{$id6}}{$type}}{$chr}}{$pp})){
				$used_pos{$pp} = 1;
				next;
			    }
			    elsif (($overlap_id eq $id6) and (!exists $used_pos{$pp}) and (exists ${${${$call{$id6}}{$type}}{$chr}}{$pp})){
				$used_pos{$pp} = 1;
				next;
			    }
			    $pos_str .= "$pp=";
			    $pos_tra_str .= "$all_pos_tra[$count_pos - 1]=";
			    $sum_pos += $pp;
			    $sum_pos_tra += $all_pos_tra[$count_pos - 1];
			    $count_sum ++;
			}
			$pos_str =~ s/=$//;
			$pos_tra_str =~ s/=$//;
			$pos_2 = int ($sum_pos / $count_sum);
			$pos_tra_2 = int ($sum_pos_tra / $count_sum);
			${$vcf_or_info{$chr}}{$pos_2} = "pair6||$pre_chr2||$pos_str||$pos_tra_str";
			delete ${$vcf_or{$chr}}{$pos};
			delete ${$vcf_or{$chr}}{$pre_pos};
			${$vcf_or{$chr}}{$pos_2} = "$pre_chr2=$pos_tra_2";
			$pre_pos = $pos_2;
			next;
		    }
		}
	    }
	    $pre_pos = $pos;
	}
    }
    
    foreach my $chr (keys %vcf_or){
	my %match2;
	foreach my $pos (sort {$a <=> $b} keys %{$vcf_or{$chr}}){
	    my ($chr2, $pos2) = split (/=/, ${$vcf_or{$chr}}{$pos});
	    my $bp_hit_flag = 0;
	    $call_or ++;
	    foreach my $bp (sort {$a <=> $b} keys %{${$ref{'TRA-I'}}{$chr}}){
		next if (exists $match2{$bp});
		my ($ref_tralen, $ref_chr2, $ref_bp2) = split (/=/, ${${$ref{'TRA-I'}}{$chr}}{$bp});
		if (abs ($pos - $bp) <= $ctx_sd){
		    $bp_hit_flag = 1;
		}
		if ($bp_hit_flag == 1){
		    if (($chr2 eq $ref_chr2) and (abs ($pos2 - $ref_bp2) <= $ctx_sd)){
			$bp_hit_flag = 2;
			$match2{$bp} = 1;
		    }
		    last;
		}
	    }
	    if ($bp_hit_flag <= 1){
		foreach my $bp (sort {$a <=> $b} keys %{${$ref{'TRA-D'}}{$chr}}){
		    next if (exists $match2{$bp});
		    my ($ref_tralen, $ref_chr2, $ref_bp2) = split (/=/, ${${$ref{'TRA-D'}}{$chr}}{$bp});
		    if (abs ($pos - $bp) <= $ctx_sd){
			$bp_hit_flag = 1.5;
		    }
		    if ($bp_hit_flag == 1.5){
			if (($chr2 eq $ref_chr2) and (abs ($pos2 - $ref_bp2) <= $ctx_sd)){
			    $bp_hit_flag = 2;
			    $match2{$bp} = 1;
			}
			last;
		    }
		}
	    }
	    if ($bp_hit_flag == 2){
		$match_or ++;
	    }
	}
    }
    my $recall_or = sprintf ("%.1f", int ($match_or / $ref_ctx_num * 1000) / 10);
    my $preci_or = 0;
    $preci_or = sprintf ("%.1f", int ($match_or / $call_or * 1000) / 10) if ($call_or > 0);
    my $recall_pair1 = $recall_and_or{$pair1};
    my $recall_pair2 = $recall_and{$pair2};
    my $pair_pair1 = "$pair1|$pair2";
    foreach my $chr (keys %vcf_or){
	foreach my $pos (keys %{$vcf_or{$chr}}){
	    my ($pair_g, $chr2_g, $pos_g, $pos_tra_g) = split (/\|\|/, ${$vcf_or_info{$chr}}{$pos});
	    ${${${$sv_and_or_or{$type}}{$pair_pair1}}{$chr}}{$pos} = "$chr2_g|$pos_g|$pos_tra_g";
	}
    }
    return ($recall_or, $preci_or);
}
=cut